{
  "username": "agilexrobotics",
  "agent_b_context": "\n=== PR #5 in westonrobot/ugv_sdk (Stars: 82) ===\nFile: ugv_sdk/src/bunker_base.cpp\nPatch:\n@@ -0,0 +1,200 @@\n+#include \"ugv_sdk/bunker/bunker_base.hpp\"\n+\n+#include <string>\n+#include <cstring>\n+#include <iostream>\n+#include <algorithm>\n+#include <array>\n+#include <chrono>\n+#include <cstdint>\n+#include <ratio>\n+#include <thread>\n+\n+#include \"stopwatch.hpp\"\n+\n+namespace westonrobot {\n+void BunkerBase::SendRobotCmd() {\n+  static uint8_t cmd_count = 0;\n+  static uint8_t light_cmd_count = 0;\n+  SendMotionCmd(cmd_count++);\n+}\n+\n+void BunkerBase::SendMotionCmd(uint8_t count) {\n+  // motion control message\n+  BunkerMessage m_msg;\n+  m_msg.type = BunkerMotionControlMsg;\n+\n+  if (can_connected_)\n+    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_CAN;\n+  else if (serial_connected_)\n+    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_UART;\n+\n+  motion_cmd_mutex_.lock();\n+  m_msg.body.motion_control_msg.data.cmd.fault_clear_flag =\n+      static_cast<uint8_t>(current_motion_cmd_.fault_clear_flag);\n+  m_msg.body.motion_control_msg.data.cmd.linear_\n... (truncated)\n\nFile: ugv_sdk/src/bunker_can_parser.c\nPatch:\n@@ -0,0 +1,161 @@\n+/* \n+ * bunker_can_parser.c\n+ * \n+ * Created on: Aug 31, 2019 04:25\n+ * Description: \n+ * \n+ * Copyright (c) 2019 Ruixiang Du (rdu)\n+ */\n+\n+#include \"ugv_sdk/bunker/bunker_can_parser.h\"\n+\n+#include \"string.h\"\n+\n+static void EncodeBunkerMotionControlMsgToCAN(const MotionControlMessage *msg, struct can_frame *tx_frame);\n+static void EncodeBunkerLightControlMsgToCAN(const LightControlMessage *msg, struct can_frame *tx_frame);\n+\n+bool DecodeBunkerMsgFromCAN(const struct can_frame *rx_frame, BunkerMessage *msg)\n+{\n+    msg->type = BunkerMsgNone;\n+\n+    switch (rx_frame->can_id)\n+    {\n+    // in the current implementation, both MsgType and can_frame include 8 * uint8_t\n+    case CAN_MSG_MOTION_CONTROL_STATUS_ID:\n+    {\n+        msg->type = BunkerMotionStatusMsg;\n+        // msg->motion_status_msg.id = CAN_MSG_MOTION_CONTROL_STATUS_ID;\n+        memcpy(msg->body.motion_status_msg.data.raw, rx_frame->data, rx_frame->can_dlc * sizeof(uint8_t));\n+        break;\n+    }\n+    cas\n... (truncated)\n\nFile: ugv_sdk/src/hunter_base.cpp\nPatch:\n@@ -1,4 +1,4 @@\n-#include \"ugv_sdk/hunter/hunter_base.hpp\"\n+#include \"ugv_sdk/hunter_v2/hunter_base.hpp\"\n \n #include <algorithm>\n #include <array>\n@@ -16,35 +16,35 @@ namespace westonrobot {\n \n void HunterBase::SendRobotCmd() {\n   static uint8_t cmd_count = 0;\n+  SendModeCtl();\n+  SetParkMode();\n   SendMotionCmd(cmd_count++);\n }\n \n void HunterBase::SendMotionCmd(uint8_t count) {\n   // motion control message\n   HunterMessage m_msg;\n-  m_msg.type = HunterMotionCmdMsg;\n-\n-  if (can_connected_)\n-    m_msg.body.motion_cmd_msg.data.cmd.control_mode = CTRL_MODE_CMD_CAN;\n+  m_msg.type = HunterMotionControlMsg;\n+  /*if (can_connected_)\n+    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_CAN;\n   else if (serial_connected_)\n-    m_msg.body.motion_cmd_msg.data.cmd.control_mode = CTRL_MODE_CMD_UART;\n-\n+    m_msg.body.motion_cmd_msg.data.cmd.control_mode = CTRL_MODE_CMD_UART*/;\n   motion_cmd_mutex_.lock();\n-  m_msg.body.motion_cmd_msg.data.cmd.fault_clear_flag =\n-      static_ca\n... (truncated)\n\nFile: ugv_sdk/src/hunter_can_parser.c\nPatch:\n@@ -7,11 +7,12 @@\n  * Copyright (c) 2019 Ruixiang Du (rdu)\n  */ \n \n-#include \"ugv_sdk/hunter/hunter_can_parser.h\"\n-\n+#include \"ugv_sdk/hunter_v2/hunter_can_parser.h\"\n #include \"string.h\"\n \n-static void EncodeHunterMotionControlMsgToCAN(const MotionCmdMessage *msg, struct can_frame *tx_frame);\n+static void EncodeHunterMotionControlMsgToCAN(const MotionControlMessage *msg, struct can_frame *tx_frame);\n+static void EncodeHunterControlModeMsgToCAN(const ModSelectMessage *msg,struct can_frame *tx_frame);\n+static void EncodeHunterControlParkMsgToCAN(const ParkControlMessage *msg,struct can_frame *tx_frame);\n \n bool DecodeHunterMsgFromCAN(const struct can_frame *rx_frame, HunterMessage *msg)\n {\n@@ -20,7 +21,7 @@ bool DecodeHunterMsgFromCAN(const struct can_frame *rx_frame, HunterMessage *msg\n     switch (rx_frame->can_id)\n     {\n     // in the current implementation, both MsgType and can_frame include 8 * uint8_t\n-    case CAN_MSG_MOTION_STATUS_ID:\n+    case CAN_MSG_MOTION_CONTROL_STATUS_ID:\n\n... (truncated)\n\nFile: ugv_sdk/src/scout_base.cpp\nPatch:\n@@ -1,5 +1,5 @@\n-#include \"ugv_sdk/scout/scout_base.hpp\"\n-\n+#include \"ugv_sdk/scout_v2/scout_base.hpp\"\n+#include <stdio.h>\n #include <string>\n #include <cstring>\n #include <iostream>\n@@ -16,6 +16,7 @@ namespace westonrobot {\n void ScoutBase::SendRobotCmd() {\n   static uint8_t cmd_count = 0;\n   static uint8_t light_cmd_count = 0;\n+  SendModeCtl();\n   SendMotionCmd(cmd_count++);\n   if (light_ctrl_requested_) SendLightCmd(light_cmd_count++);\n }\n@@ -25,49 +26,68 @@ void ScoutBase::SendMotionCmd(uint8_t count) {\n   ScoutMessage m_msg;\n   m_msg.type = ScoutMotionControlMsg;\n \n-  if (can_connected_)\n-    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_CAN;\n-  else if (serial_connected_)\n-    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_UART;\n+//  if (can_connected_)\n+//    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD_CAN;\n+//  else if (serial_connected_)\n+//    m_msg.body.motion_control_msg.data.cmd.control_mode = CTRL_MODE_CMD\n... (truncated)\n\n\n=== PR #4 in westonrobot/ugv_sdk (Stars: 82) ===\n\n=== PR #237 in ros-infrastructure/robots.ros.org (Stars: 80) ===\n"
}