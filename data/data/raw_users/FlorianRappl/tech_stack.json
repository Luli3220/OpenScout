[
  {
    "name": "FlorianRappl/CmdParser",
    "stars": 217,
    "description": "A simple and lightweight command line parser using C++11.",
    "languages_breakdown": {
      "C++": 683842,
      "CMake": 538
    },
    "files": {
      "README.md": "# Simple C++ command line parser\n\nThis project supplies a simple, single-header, command-line parser. It is very lightweight and relies on templates. The easiest way is to use it by adding it to your source code. The parser requires C++11 and works fine on gcc (v4.8.2 or later, some earlier versions should work as well), icc (v14 or later), clang and msvc (v18 or later).\n\n## Using the parser\n\nUsing the parser is straight forward. Only include the header (*cmdparser.h*) in your application source file, most likely the one that contains the `main` method. Pass the command line arguments to the parser:\n\n```cpp\nint main(int argc, char** argv) {\n\tcli::Parser parser(argc, argv);\n\t/* ... */\n}\n```\n\nIn the following two sections we'll have a look at setting up the parser and using it.\n\n### Setup\n\nSetting up the parser works using the following methods:\n\n* `set_optional<T>()`, to include an optional argument\n* `set_required<T>()`, to include a required argument\n\nThe third parameter for creating an optional argument is the default value. This value is used if nothing is provided by the user. Otherwise the optional and required methods are pretty similar:\n\n1. The shorthand (if the user uses a single slash) string\n2. The longhand (if the user uses two slashes) string\n3. The optional description.\n\nThe third parameter is the fourth parameter for optional arguments.\n\nLet's look at an example:\n\n```cpp\nvoid configure_parser(cli::Parser& parser) {\n\tparser.set_optional<std::string>(\"o\", \"output\", \"data\", \"Strings are naturally included.\");\n\tparser.set_optional<int>(\"n\", \"number\", 8, \"Integers in all forms, e.g., unsigned int, long long, ..., are possible. Hexadecimal and Ocatl numbers parsed as well\");\n\tparser.set_optional<cli::NumericalBase<int, 10>>(\"t\", \"temp\", 0, \"integer parsing restricted only to numerical base 10\");\n\tparser.set_optional<double>(\"b\", \"beta\", 11.0, \"Also floating point values are possible.\");\n\tparser.set_optional<bool>(\"a\", \"all\", false, \"Boolean arguments are simply switched when encountered, i.e. false to true if provided.\");\n\tparser.set_required<std::vector<short>>(\"v\", \"values\", \"By using a vector it is possible to receive a multitude of inputs.\");\n}\n```\n\nUsually it makes sense to pack the Parser's setup in a function. But of course this is not required. The shorthand is not limited to a single character. It could also be the same as the longhand alternative.\n\n### Getting values\n\nGetting values is possible via the `get` method. This is also a template. We need to specify the type of argument. This has to be the same type as defined earlier. It also has to be a valid argument (shorthand) name. At the moment only shorthands are considered here. For instance we could do the following:\n\n```cpp\n//auto will be int\nauto number = parser.get<int>(\"n\");\n\n//auto will be int, note specification of numerical base same as when set during parser configuration\nauto number = parser.get<cli::NumericalBase<int, 10> >(\"t\");\n\n//auto will be std::string\nauto out\n... (truncated)"
    }
  },
  {
    "name": "FlorianRappl/Mages",
    "stars": 130,
    "description": ":tophat: MAGES is a very simple, yet powerful, expression parser and interpreter.",
    "languages_breakdown": {
      "C#": 1112821,
      "PowerShell": 2371,
      "Shell": 2304
    },
    "files": {
      ".github/workflows/ci.yml": "name: CI\n\non: [push, pull_request]\n\nenv:\n  NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}\n  GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n  CHOCOLATEY_API_KEY: ${{ secrets.CHOCOLATEY_API_KEY }}\n\njobs:\n  # linux:\n  #   runs-on: ubuntu-latest\n\n  #   steps:\n  #   - uses: actions/checkout@v2\n\n  #   - uses: actions/setup-dotnet@v3\n  #     with:\n  #       dotnet-version: |\n  #         5.0.x\n  #         6.0.x\n  #         7.0.x\n  #         8.0.x\n  #         9.0.x\n  #         10.0.x\n\n  #   - name: Build\n  #     run: ./build.sh\n\n  windows:\n    runs-on: windows-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - uses: actions/setup-dotnet@v3\n      with:\n        dotnet-version: |\n          5.0.x\n          6.0.x\n          7.0.x\n          8.0.x\n          9.0.x\n          10.0.x\n\n    - name: Build\n      run: |\n        if ($env:GITHUB_REF -eq \"refs/heads/main\") {\n          .\\build.ps1 -Target Publish\n        } elseif ($env:GITHUB_REF -eq \"refs/heads/devel\") {\n          .\\build.ps1 -Target PrePublish\n        } else {\n          .\\build.ps1\n        }\n",
      "README.md": "![MAGES Logo](./logo.png)\n\n# MAGES\n\n[![GitHub CI](https://github.com/FlorianRappl/Mages/actions/workflows/ci.yml/badge.svg)](https://github.com/FlorianRappl/Mages/actions/workflows/ci.yml) [![NuGet](https://img.shields.io/nuget/v/MAGES.svg?style=flat-square)](https://www.nuget.org/packages/Mages/) [![Issues](https://img.shields.io/github/issues/FlorianRappl/MAGES.svg?style=flat-square)](https://github.com/FlorianRappl/Mages/issues)\n\n## Mages: Another Generalized Expression Simplifier\n\nMAGES is the official successor to [YAMP](https://github.com/FlorianRappl/YAMP). It is a very simple, yet powerful, expression parser and interpreter. You can use MAGES to include a sophisticated, easy to customize, and lightweight scripting engine to your application.\n\nAmong other applications, MAGES has been used in [Microsoft's PowerToys](https://github.com/microsoft/PowerToys).\n\n### Current Status\n\n**2024**:\n\nMAGES was just updated (v3.0.0) with object metadata, direct list support, and JSX syntax.\n\nJSX as you know it - stringified via `html`:\n\n```plain\n<div class={\"hello\" + \",\" + \"there\"}><h1>Hi</h1><p>World.</p></div> | html\n// result: <div class=\"hello,there\"><h1>Hi</h1><p>World.</p></div>\n```\n\nObject metadata reflected via `type`:\n\n```plain\nnew { a: \"foo\", b: 42 } | type | json\n// {\n//   \"name\": \"Object\",\n//   \"create\": \"[Function]\",\n//   \"keys\": {\n//     \"0\": \"a\",\n//     \"1\": \"b\"\n//   }\n// }\n\n((x, y, z) => x + y + z) | type | json\n// {\n//   \"name\": \"Function\",\n//   \"create\": \"[Function]\",\n//   \"parameters\": {\n//     \"0\": \"x\",\n//     \"1\": \"y\",\n//     \"2\": \"z\"\n//   }\n// }\n```\n\nPlaceholders for calling functions / specifying what should be curry'ed:\n\n```plain\nvar f = (x, y, z) => x + 2 * y + 3 * z;\n5 | f(1, _, 2)\n// 17, by computing 1 + 2 * 5 + 3 * 2\n```\n\n### Previous Status\n\n**2023**:\n\nMAGES was updated (v2.0.0) with support for complex numbers. Also, the build target and runtime has been updated to make use of modern possibilities.\n\n**2018**:\n\nThe first stable version has been released. The current version 1.6.0 contains an improved REPL. The library contains everything to perform lightweight scripting operations in C#. A [CodeProject article](http://www.codeproject.com/Articles/1108939/MAGES-Ultimate-Scripting-for-NET) about the library (also containing some background and performance comparisons) is also available.\n\n### Installation\n\nMAGES itself does not have any dependencies, however, the tests are dependent on NUnit and the benchmarks use BenchmarkDotNet. Usually, MAGES should be installed via the NuGet package source. If this does not work for you, then clone the source and build MAGES yourself. Make sure that all unit tests pass.\n\nThe whole library was designed to be consumed from .NET Core 3.0 (or higher) / .NET 5.0 (or higher) applications. This means it is (amongst others) compatible with Unity 2021.2 or Mono 6.4. The NuGet package is available via [the official package feed](https://www.nuget.org/packages/MAGES).\n\n### Get Me Started!\n\nIn the most \n... (truncated)"
    }
  },
  {
    "name": "FlorianRappl/Mario5TS",
    "stars": 61,
    "description": "The TypeScript version of the Mario5 demo application.",
    "languages_breakdown": {
      "TypeScript": 103458,
      "CSS": 1579,
      "HTML": 188,
      "JavaScript": 176
    },
    "files": {
      "package.json": "{\n  \"name\": \"mario5\",\n  \"version\": \"3.0.0\",\n  \"description\": \"TypeScript version of the Mario5 demo application.\",\n  \"main\": \"dist/index.js\",\n  \"typings\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"start\": \"npm run build:debug\",\n    \"lint\": \"tslint -c tslint.json 'src/**/*.{ts,tsx}'\",\n    \"test\": \"npm run lint\",\n    \"prettier\": \"prettier --config prettier.config.js --write src/**/*.{ts,tsx}\",\n    \"build:production\": \"parcel build src/index.html\",\n    \"build:debug\": \"parcel src/index.html\",\n    \"build:types\": \"tsc --emitDeclarationOnly\",\n    \"build\": \"rimraf dist && npm run build:production && npm run build:types\"\n  },\n  \"author\": \"Florian Rappl\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"parcel-bundler\": \"1.12.4\",\n    \"parcel-plugin-codegen\": \"0.5.0\",\n    \"prettier\": \"1.19.1\",\n    \"rimraf\": \"^2.6.3\",\n    \"sass\": \"^1.23.6\",\n    \"tslint\": \"^5.17.0\",\n    \"tslint-config-prettier\": \"^1.18.0\",\n    \"tslint-plugin-prettier\": \"^1.3.0\",\n    \"typescript\": \"^3.5.2\"\n  }\n}\n",
      "README.md": "# Mario5 TS\n\nThis repository contains the code for the TypeScript version of the Mario5 demo application.\n\n**[Online demo at mario5ts.florian-rappl.de](https://mario5ts.florian-rappl.de)**\n\n## Requirements\n\nFor compiling the code you will need the following applications:\n\n* Node.js (tested with v10) for running gulp\n* NPM (tested with v6) for installation\n\nThe rest will be installed upon local installation.\n\n# Installation\n\nFirst you should clone the repository. Then in the directory of the repository run\n\n```sh\nnpm install\n```\n\nIf you want to run the game just type in\n\n```sh\nnpm start\n```\n\nOtherwise if you want to build it for deployment, run\n\n```sh\nnpm run build\n```\n\n## Releases\n\n### Current\n\n(branch: `master`)\n\n* Refined use of modern module system\n* Use Parcel for bundling\n* Generate repetitive code\n* Use SASS for the style\n\n### Fusebox\n\n(tag: `fuse`)\n\n* Use modern module system\n* Apply FuseBox for bundling\n* Standard CSS for the style\n* Removed jQuery (completely DOM standard rendering)\n\n### Legacy\n\n(tag: `legacy`)\n\n* The original JavaScript code is available in `src/Original`.\n* The description below hints, where features of TypeScript have been placed.\n* An article describing the original code is available on [CodeProject](http://www.codeproject.com/Articles/396959/Mario).\n* The system is built by using `gulp`.\n\nThe legacy branch README also contains some more background information.\n"
    }
  }
]