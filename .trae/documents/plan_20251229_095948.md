# AI模型集成方案：基于ChatECNU API的查询向量生成

## 一、方案概述

本方案旨在集成华东师范大学的ChatECNU API，实现将自然语言查询转换为向量的功能，解决当前匹配度显示为0的问题。基于现有代码结构和用户提供的API信息，我们将添加ChatECNU API调用逻辑，生成查询向量，并用于开发者搜索。

## 二、配置文件修改

### 1. 配置项设计
在 `config.json` 中添加ChatECNU API相关配置项：

```json
{
  "github_token": "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",
  "github_tokens": [
    "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"
  ],
  "maxkb_api_url": "http://localhost:8080/chat/api/019b68d0-6848-79b1-b68f-8542adaa1d13",
  "maxkb_api_key": "application-c09d551784288f60a8276b38bcb07924",
  "ai_model": {
    "provider": "chatecnu",
    "api_url": "https://chat.ecnu.edu.cn/open/api/v1/chat/completions",
    "api_key": "sk-72af4f8c5116414eb6dba5250d1c38c9",
    "model_name": "ecnu-plus",
    "dimension": 1024  # 假设向量维度，实际根据API返回调整
  }
}
```

## 三、后端代码修改

### 1. 添加ChatECNU API调用函数
在 `server.py` 中添加ChatECNU API调用函数，用于生成查询向量：

```python
def generate_vector_chatecnu(text, ai_config):
    """Generate vector using ChatECNU API"""
    api_url = ai_config.get("api_url")
    api_key = ai_config.get("api_key")
    model_name = ai_config.get("model_name", "ecnu-plus")
    
    if not api_url or not api_key:
        return None
    
    try:
        # 构建请求体
        payload = {
            "messages": [
                {
                    "role": "system",
                    "content": "你是一个专业的文本向量化工具，请将用户输入的自然语言查询转换为向量格式。仅返回向量数组，不要包含任何其他解释或说明。向量长度应与开发者向量一致（10个维度）。"
                },
                {
                    "role": "user",
                    "content": text
                }
            ],
            "stream": False,
            "model": model_name
        }
        
        # 设置请求头
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        
        # 发送请求
        response = requests.post(api_url, json=payload, headers=headers, timeout=30)
        
        if response.status_code != 200:
            print(f"ChatECNU API error: {response.text}")
            return None
        
        # 解析响应
        data = response.json()
        vector_str = data.get("choices", [{}])[0].get("message", {}).get("content", "")
        
        # 尝试解析向量字符串
        try:
            # 移除可能的markdown代码块和空格
            vector_str = vector_str.replace("```json", "").replace("```", "").strip()
            vector = json.loads(vector_str)
            
            # 验证向量格式
            if isinstance(vector, list) and all(isinstance(x, (int, float)) for x in vector):
                # 确保向量维度与开发者向量一致（10个维度）
                if len(vector) != 10:
                    # 调整向量维度，如截断或补零
                    if len(vector) > 10:
                        vector = vector[:10]
                    else:
                        vector.extend([0.0] * (10 - len(vector)))
                return vector
            else:
                print(f"Invalid vector format from ChatECNU: {vector_str}")
                return None
        except json.JSONDecodeError:
            print(f"Failed to parse vector from ChatECNU: {vector_str}")
            return None
    except Exception as e:
        print(f"Error generating vector with ChatECNU: {str(e)}")
        return None
```

### 2. 修改向量生成函数
更新 `generate_vector_from_text` 函数，添加ChatECNU支持：

```python
def generate_vector_from_text(text, config):
    """Generate vector from text using AI model"""
    ai_config = config.get("ai_model", {})
    provider = ai_config.get("provider", "")
    
    if provider == "chatecnu":
        return generate_vector_chatecnu(text, ai_config)
    else:
        # Fallback to default vector if provider is not supported
        return None
```

### 3. 修改search_users函数
在 `search_users` 函数中集成ChatECNU API生成查询向量的逻辑：

```python
@app.post("/api/search")
def search_users(query: dict):
    """Search users based on natural language query or vector"""
    print(f"--- Searching Users: {query} ---)
    
    # Load developer vectors
    vectors = load_developer_vectors()
    if not vectors:
        raise HTTPException(status_code=500, detail="No developer vectors found")
    
    # Extract query information
    query_text = query.get("query", "")
    query_vector = query.get("vector")
    limit = query.get("limit", 10)
    
    # Generate vector from query text if no vector is provided
    if not query_vector and query_text:
        print(f"Generating vector from text: {query_text}")
        # Load AI config
        ai_config = config.get("ai_model", {})
        if ai_config:
            # Generate vector using ChatECNU API
            query_vector = generate_vector_chatecnu(query_text, ai_config)
            if query_vector:
                print(f"Generated vector: {query_vector}")
            else:
                print("Failed to generate vector, using default")
    
    # Fallback to default vector if AI model failed or no query text
    if not query_vector:
        # Default vector (all zeros)
        first_username = next(iter(vectors.keys()), None)
        if not first_username:
            return []
        vector_length = len(vectors[first_username])
        query_vector = [0.0] * vector_length
        print(f"Using default vector of length: {vector_length}")
    
    # Search developers
    results = search_developers(query_vector, vectors, limit)
    
    # Format results
    formatted_results = []
    for username, similarity in results:
        # Get user profile information
        profile = load_cached_github_profile(username) or {}
        github_info = {
            "login": profile.get("login", username),
            "name": profile.get("name", username),
            "avatar_url": profile.get("avatar_file") and f"/api/avatar/{username}" or profile.get("avatar_remote_url")
        }
        
        formatted_results.append({
            "username": username,
            "similarity": similarity,
            "profile": github_info
        })
    
    return formatted_results
```

## 三、配置文件更新

将用户提供的API Key和配置信息更新到 `config.json` 文件中：

```json
{
  "github_token": "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",
  "github_tokens": [
    "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"
  ],
  "maxkb_api_url": "http://localhost:8080/chat/api/019b68d0-6848-79b1-b68f-8542adaa1d13",
  "maxkb_api_key": "application-c09d551784288f60a8276b38bcb07924",
  "ai_model": {
    "provider": "chatecnu",
    "api_url": "https://chat.ecnu.edu.cn/open/api/v1/chat/completions",
    "api_key": "sk-72af4f8c5116414eb6dba5250d1c38c9",
    "model_name": "ecnu-plus",
    "dimension": 10
  }
}
```

## 四、测试与部署

### 1. 测试步骤

1. **更新配置文件**：将上述配置信息更新到 `config.json` 文件中
2. **启动服务**：运行 `python server.py` 或使用nohup在后台运行
3. **测试API**：使用curl或Postman测试 `/api/search` 端点
4. **前端测试**：访问 http://localhost:8001，测试智能搜索功能
5. **查看日志**：查看服务日志，检查ChatECNU API调用是否成功

### 2. 示例API请求

```bash
curl -X POST -H "Content-Type: application/json" -d '{"query": "我需要一个擅长设计前端界面的人才", "limit": 5}' http://localhost:8001/api/search
```

### 3. 预期结果

成功调用ChatECNU API后，搜索结果中的 `similarity` 字段将不再是0.0，而是一个0到1之间的相似度值，反映了开发者与查询的匹配程度。

## 五、风险与解决方案

1. **API调用失败**：
   - 解决方案：添加重试机制和降级策略，失败时回退到默认向量

2. **向量维度不匹配**：
   - 解决方案：添加向量维度检查和调整逻辑，确保查询向量和开发者向量维度一致

3. **API费用控制**：
   - 解决方案：添加API调用次数限制和费用监控，避免超出预算

4. **响应时间过长**：
   - 解决方案：考虑添加缓存机制，缓存频繁查询的向量，减少API调用次数

5. **向量质量问题**：
   - 解决方案：优化prompt设计，确保生成的向量能够准确反映查询的语义

## 六、后续优化

1. **prompt优化**：进一步优化system prompt，提高向量生成质量
2. **向量归一化**：添加向量归一化步骤，确保向量在相同的尺度上进行比较
3. **多轮对话支持**：考虑支持多轮对话，允许用户细化搜索需求
4. **搜索结果解释**：添加搜索结果的解释功能，说明为什么某个开发者与查询匹配
5. **个性化搜索**：基于用户历史搜索记录，提供个性化搜索结果

## 七、所需资源

1. **ChatECNU API Key**：用户已提供
2. **服务器资源**：确保服务器有足够的网络带宽，支持API调用
3. **开发时间**：预计需要1天时间完成集成和测试

## 八、总结

本方案提供了一个完整的ChatECNU API集成方案，专门针对用户提供的API进行了优化。通过集成这个API，我们将实现查询向量的生成，解决当前匹配度显示为0的问题，提高智能搜索功能的实用性和准确性。

该方案具有良好的扩展性和灵活性，可以根据需要进一步优化和调整。同时，方案也考虑了错误处理、性能优化和部署建议，确保系统的稳定性和可靠性。