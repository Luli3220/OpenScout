{
  "username": "cyberglot",
  "agent_b_context": "\n=== PR #18064 in is-a-dev/register (Stars: 9251) ===\n\n=== PR #30 in swaits/typst-collection (Stars: 48) ===\n\n=== PR #18 in NillionNetwork/client-ts (Stars: 13) ===\n\n=== Fallback Source Audit: dhall/src/syntax/text/parser.rs (Size: 35577 bytes) ===\nuse itertools::Itertools;\nuse pest::prec_climber as pcl;\nuse pest::prec_climber::PrecClimber;\nuse std::collections::{BTreeMap, BTreeSet};\nuse std::iter::once;\nuse std::rc::Rc;\n\nuse pest_consume::{match_nodes, Parser};\n\nuse crate::operations::OpKind::*;\nuse crate::syntax::ExprKind::*;\nuse crate::syntax::NumKind::*;\nuse crate::syntax::{\n    Double, Expr, FilePath, FilePrefix, Hash, ImportMode, ImportTarget,\n    Integer, InterpolatedText, InterpolatedTextContents, Label, NaiveDouble,\n    Natural, Scheme, Span, UnspannedExpr, URL, V,\n};\n\n// This file consumes the parse tree generated by pest and turns it into\n// our own AST. All those custom macros should eventually moved into\n// their own crate because they are quite general and useful. For now they\n// are here and hopefully you can figure out how they work.\n\ntype ParsedText = InterpolatedText<Expr>;\ntype ParsedTextContents = InterpolatedTextContents<Expr>;\ntype ParseInput<'input> = pest_consume::Node<'input, Rule, Rc<str>>;\n\npub type ParseError = pest::error::Error<Rule>;\npub type ParseResult<T> = Result<T, ParseError>;\n\n#[derive(Debug)]\nenum Selector {\n    Field(Label),\n    Projection(BTreeSet<Label>),\n    ProjectionByExpr(Expr),\n}\n\nfn input_to_span(input: ParseInput) -> Span {\n    Span::make(input.user_data().clone(), input.as_pair().as_span())\n}\nfn spanned(input: ParseInput, x: UnspannedExpr) -> Expr {\n    Expr::new(x, input_to_span(input))\n}\nfn spanned_union(span1: Span, span2: Span, x: UnspannedExpr) -> Expr {\n    Expr::new(x, span1.union(&span2))\n}\n\n// Trim the shared indent off of a vec of lines, as defined by the Dhall semantics of multiline\n// literals.\nfn trim_indent(lines: &mut Vec<ParsedText>) {\n    let is_indent = |c: char| c == ' ' || c == '\\t';\n\n    // There is at least one line so this is safe\n    let last_line_head = lines.last().unwrap().head();\n    let indent_chars = last_line_head\n        .char_indices()\n        .take_while(|(_, c)| is_indent(*c));\n    let mut min_indent_idx = match indent_chars.last() {\n        Some((i, _)) => i,\n        // If there is no indent char, then no indent needs to be stripped\n        None => return,\n    };\n\n    for line in lines.iter() {\n        // Ignore empty lines\n        if line.is_empty() {\n            continue;\n        }\n        // Take chars from line while they match the current minimum indent.\n        let indent_chars = last_line_head[0..=min_indent_idx]\n            .char_indices()\n            .zip(line.head().chars())\n            .take_while(|((_, c1), c2)| c1 == c2);\n        match indent_chars.last() {\n            Some(((i, _), _)) => min_indent_idx = i,\n            // If there is no indent char, then no indent needs to be stripped\n            None => return,\n        };\n    }\n\n    // Remove the shared indent from non-empty lines\n    for line in lines.iter_mut() {\n        if !line.is_empty() {\n            line.head_mut().replace_range(0..=min_indent_idx, \"\");\n        }\n    }\n}\n\n/// Insert the expr into the map; in case of collision, create \n... (file truncated)\n"
}