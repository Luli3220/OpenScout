[
  {
    "name": "kixelated/moq-js",
    "stars": 156,
    "description": "Typescript library for Media over QUIC",
    "languages_breakdown": {},
    "files": {
      "README.md": "# Deprecated\nMoved to [kixelated/moq](https://github.com/kixelated/moq).\n\nIt's much better now.\n"
    }
  },
  {
    "name": "kixelated/steamcache",
    "stars": 28,
    "description": "network HTTP cache for popular game clients",
    "languages_breakdown": {},
    "files": {
      "docker-compose.yml": "version: \"3\"\n\nservices:\n  http:\n    build: \"http\"\n    image: steamcache-http:latest\n    ports:\n      - \"80:80/tcp\"\n    volumes:\n      - \"data:/data\"\n\n  dns:\n    build: \"dns\"\n    image: steamcache-dns:latest\n    ports:\n      - \"53:53/udp\"\n\n  sni:\n    build: \"sni\"\n    image: steamcache-sni:latest\n    ports:\n      - \"443:443/tcp\"\n\nvolumes:\n  data:\n",
      "README.md": "# Game Download Cache Docker Container\n\n## Introduction\n\nSteamcache is a caching proxy server for game download content. Any game downloads made on the network will be cached to disk and reused for future downloads. This can dramatically reduce internet usage while also increasing subsequent download speeds. The only limit is the size/speed of the cache on disk and speed of the local network.\n\nThe primary use case is gaming events, such as LAN parties, which need to be able to cope with hundreds or thousands of computers receiving an unannounced patch - without spending a fortune on internet connectivity. Other uses include smaller networks, such as Internet Cafes and home networks, where the new games are regularly installed on multiple computers; or multiple independent operating systems on the same computer.\n\nThis container is designed to support any game that uses HTTP. This makes it suitable for:\n\n - Steam (Valve)\n - Battle.net (Blizzard)\n - Origin (EA Games)\n - League of Legends (Riot Games)\n - Frontier Launchpad\n - Uplay (Ubisoft)\n - Windows Updates\n\n## Usage\n\nStart by installing [docker](https://docs.docker.com/engine/installation/) and [docker-compose](https://docs.docker.com/compose/install/).\n\nClone this repository and the submodules.\n\n    git clone --recursive https://github.com/kixelated/steamcache.git\n\nOpen up `docker-compose.override.yml`. You will need to change `LANCACHE_IP` from the default `10.0.0.3` to the host's IP address.\n\nRun the following command to build all of the containers and start them:\n\n    docker-compose up --build\n\nYou can also use the `-d` argument to run these in the background, in which case you use `docker-compose logs` to view the logs and `docker-compose down` to stop everything.\n\nFinally, grab a computer with Steam and change the network DNS server to the IP address of the host running steamcache. Flush your DNS and try downloading some games; you should see downloads in the steamcache logs!\n\n## Quick Explanation\n\nSteamcache is broken into three parts:\n\n* A DNS proxy (steamcache-dns)\n* A HTTP game cache and proxy (steamcache-http)\n* A HTTPS proxy (steamcache-sni)\n\nSteam and most other game clients use HTTP servers to download files. Steamcache works by running a custom DNS server that returns normal results, except for a curated list of domains. For these downloads we return the IP address of the steamcache host instead which will be inside the network.\n\nThe steamcache host runs its own HTTP server that will handle these download requests normally intended for the game content servers. The file is served from disk if it's stored in the cache. Otherwise, the file is downloaded and stored in the cache for future requests.\n\nThe final component is a optional HTTPS proxy that fixes some edge cases. Unfortunately, it's only possible to cache HTTP requests and some services mix HTTP and HTTPS on the same domain. The SNI proxy forwards any HTTPS requests that were incorrectly sent to steamcache via DNS.\n\n## Full S\n... (truncated)"
    }
  },
  {
    "name": "kixelated/mp4-atom",
    "stars": 23,
    "description": "A Rust MP4/ISOBMFF encoder and decoder",
    "languages_breakdown": {
      "Rust": 644296,
      "Just": 816,
      "RenderScript": 1
    },
    "files": {
      "Cargo.toml": "[package]\nname = \"mp4-atom\"\ndescription = \"A MP4/ISOBMFF atom decoder and encoder\"\nauthors = [\"Luke Curley <kixelated@gmail.com>\"]\nrepository = \"https://github.com/kixelated/mp4-atom\"\nlicense = \"MIT OR Apache-2.0\"\n\nversion = \"0.9.2\"\nedition = \"2021\"\n\nkeywords = [\"mp4\", \"isobmff\", \"mp4box\", \"audio\", \"video\"]\ncategories = [\"multimedia::encoding\"]\n\n[dependencies]\npaste = \"1\"\nthiserror = \"1\"\nnum = \"0.4\"\ntracing = \"0.1\"\nderive_more = { version = \"2\", features = [\"from\"] }\n\nbytes = { version = \"1\", optional = true }\ntokio = { version = \"1\", features = [\"io-util\"], optional = true }\nserde = { version = \"1\", features = [\"derive\"], optional = true }\n\n[features]\ntokio = [\"dep:tokio\"]\nbytes = [\"dep:bytes\"]\nserde = [\"dep:serde\", \"bytes/serde\"]\n\n[dev-dependencies]\nanyhow = \"1\"\ntracing-subscriber = \"0.3\"\n",
      "README.md": "[![crates.io](https://img.shields.io/crates/v/mp4-atom)](https://crates.io/crates/mp4-atom)\n[![docs.rs](https://img.shields.io/docsrs/mp4-atom)](https://docs.rs/mp4-atom)\n[![discord](https://img.shields.io/discord/1124083992740761730)](https://discord.gg/FCYF3p99mr)\n\n# mp4-atom\nThis library provides encoding for the ISO Base Media File Format (ISO/IEC 14496-12).\nIt's meant to be low level, performing encoding/decoding of the binary format without\nvalidation or interpretation of the data. You have to know what boxes to expect!\n\n## Atoms\nMP4 files are made up of atoms, which are boxes of data.\nThey have an upfront size and a 4-byte code to identify the type of box.\nExamples include `moov`, `mdat`, `trak`, etc.\n\nUnfortunately, the specification is quite complex and often gated behind a paywall.\nUsing this library does require some additional knowledge of the format otherwise you should use a higher level library.\n\nSee the [documentation](https://docs.rs/mp4-atom).\n\n## Examples\n### Decoding/encoding a byte buffer\n```rust\nuse bytes::{Bytes, BufMut};\nuse mp4_atom::{Any, Encode, Decode, Ftyp};\n\n // A simple ftyp atom\nlet mut input = Bytes::from_static(b\"\\0\\0\\0\\x14ftypiso6\\0\\0\\x02\\0mp41\");\nlet atom = Any::decode(&mut input.clone())?;\n\n// Make sure we got the right atom\nassert_eq!(atom, Ftyp {\n   major_brand: b\"iso6\".into(),\n   minor_version: 512,\n   compatible_brands: vec![b\"mp41\".into()],\n}.into());\n\n// Encode it back\nlet mut output = BufMut::new();\natom.encode(&mut output)?;\n\nassert_eq!(input, output.freeze());\n```\n\n### Synchronous IO\nNOTE: reading a `Mdat` atom will read the entire contents into memory.\nSee the next example to avoid this.\n\n```rust\nuse mp4_atom::{Any, ReadFrom, WriteTo, Ftyp};\n\nlet mut reader = std::io::stdin();\nlet atom = Any::read_from(&mut reader)?;\n\n// Make sure we got the right atom\nassert_eq!(atom, Ftyp {\n   major_brand: b\"iso6\".into(),\n   minor_version: 512,\n   compatible_brands: vec![b\"mp41\".into()],\n}.into());\n\n// Encode it back to a Write type\nlet writer = std::io::stdout();\natom.write_to(&mut writer)?;\n```\n\n### Handling large atoms\nTo avoid reading large files into memory, you can call `Header::read_from` manually:\n\n```rust\nuse mp4_atom::{Atom, Any, Header, ReadFrom, ReadAtom, WriteTo, Ftyp, Moov};\n\nlet mut reader = std::io::stdin();\n\nlet header = Header::read_from(&mut reader)?;\nmatch header.kind {\n  Ftyp::KIND => {\n    let ftyp = Ftyp::read_atom(&header, &mut reader)?;\n\n     // Make sure we got the right atom\n     assert_eq!(ftyp, Ftyp {\n       major_brand: b\"iso6\".into(),\n       minor_version: 512,\n       compatible_brands: vec![b\"mp41\".into()],\n     });\n   },\n   Moov::KIND => {\n     // Manually decode the moov\n     match header.size {\n       Some(size) => { /* read size bytes */ },\n       None => { /* read until EOF */ },\n     };\n   },\n   _ => {\n     // You can also use Any if you prefer\n     let any = Any::read_atom(&header, &mut reader)?;\n     println!(\"Unknown atom: {:?}\", any);\n   }\n};\n```\n\n### Asynchronous IO\nEnable\n... (truncated)"
    }
  }
]