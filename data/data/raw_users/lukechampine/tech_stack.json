[
  {
    "name": "lukechampine/jsteg",
    "stars": 635,
    "description": "JPEG steganography",
    "languages_breakdown": {
      "Go": 63050
    },
    "files": {
      "go.mod": "module lukechampine.com/jsteg\n\ngo 1.17\n\nrequire lukechampine.com/flagg v1.1.1\n",
      "README.md": "jsteg\n-----\n\n[![GoDoc](https://godoc.org/lukechampine.com/jsteg?status.svg)](https://godoc.org/lukechampine.com/jsteg)\n[![Go Report Card](http://goreportcard.com/badge/lukechampine.com/jsteg)](https://goreportcard.com/report/lukechampine.com/jsteg)\n\n```\ngo get lukechampine.com/jsteg\n```\n\n`jsteg` is a package for hiding data inside jpeg files, a technique known as\n[steganography](https://en.wikipedia.org/wiki/steganography). This is accomplished\nby copying each bit of the data into the least-significant bits of the image.\nThe amount of data that can be hidden depends on the filesize of the jpeg; it\ntakes about 10-14 bytes of jpeg to store each byte of the hidden data.\n\n## Example\n\n```go\n// open an existing jpeg\nf, _ := os.Open(filename)\nimg, _ := jpeg.Decode(f)\n\n// add hidden data to it\nout, _ := os.Create(outfilename)\ndata := []byte(\"my secret data\")\njsteg.Hide(out, img, data, nil)\n\n// read hidden data:\nhidden, _ := jsteg.Reveal(out)\n```\n\nNote that the data is not demarcated in any way; the caller is responsible for\ndetermining which bytes of `hidden` it cares about. The easiest way to do this\nis to prepend the data with its length.\n\nA `jsteg` command is included, providing a simple wrapper around the\nfunctions of this package. It can hide and reveal data in jpeg files and\nsupports input/output redirection. It automatically handles length prefixes\nand uses a magic header to identify jpegs that were produced by `jsteg`.\n\nA more narrowly-focused command named `slink` is also included. `slink` embeds\na public key in a jpeg, and makes it easy to sign data and verify signatures\nusing keypairs derived from password strings. See [cmd/slink](cmd/slink) for a\nfull description.\n\nBinaries for both commands can be found [here](https://github.com/lukechampine/jsteg/releases).\n\n---\n\nThis package reuses a significant amount of code from the image/jpeg package.\nThe BSD-style license that governs the use of that code can be found in the\n`go_LICENSE` file.\n"
    }
  },
  {
    "name": "lukechampine/blake3",
    "stars": 406,
    "description": "An AVX-512 accelerated implementation of the BLAKE3 cryptographic hash function",
    "languages_breakdown": {
      "Assembly": 130047,
      "Go": 65972
    },
    "files": {
      "go.mod": "module lukechampine.com/blake3\n\ngo 1.22\n\nrequire github.com/klauspost/cpuid/v2 v2.0.9\n\nretract v1.4.0 // https://github.com/lukechampine/blake3/pull/26\n",
      "README.md": "blake3\n------\n\n[![GoDoc](https://godoc.org/lukechampine.com/blake3?status.svg)](https://godoc.org/lukechampine.com/blake3)\n[![Go Report Card](http://goreportcard.com/badge/lukechampine.com/blake3)](https://goreportcard.com/report/lukechampine.com/blake3)\n\n```\ngo get lukechampine.com/blake3\n```\n\n`blake3` implements the [BLAKE3 cryptographic hash function](https://github.com/BLAKE3-team/BLAKE3).\nThis implementation aims to be performant without sacrificing (too much)\nreadability, in the hopes of eventually landing in `x/crypto`.\n\nIn addition to the pure-Go implementation, this package also contains AVX-512\nand AVX2 routines (generated by [`avo`](https://github.com/mmcloughlin/avo))\nthat greatly increase performance for large inputs and outputs.\n\n## Benchmarks\n\nTested on a 2020 MacBook Air (i5-7600K @ 3.80GHz). Benchmarks will improve as\nsoon as I get access to a beefier AVX-512 machine. :wink:\n\n### AVX-512\n\n```\nBenchmarkSum256/64           120 ns/op       533.00 MB/s\nBenchmarkSum256/1024        2229 ns/op       459.36 MB/s\nBenchmarkSum256/65536      16245 ns/op      4034.11 MB/s\nBenchmarkWrite               245 ns/op      4177.38 MB/s\nBenchmarkXOF                 246 ns/op      4159.30 MB/s\n```\n\n### AVX2\n\n```\nBenchmarkSum256/64           120 ns/op       533.00 MB/s\nBenchmarkSum256/1024        2229 ns/op       459.36 MB/s\nBenchmarkSum256/65536      31137 ns/op      2104.76 MB/s\nBenchmarkWrite               487 ns/op      2103.12 MB/s\nBenchmarkXOF                 329 ns/op      3111.27 MB/s\n```\n\n### Pure Go\n\n```\nBenchmarkSum256/64           120 ns/op       533.00 MB/s\nBenchmarkSum256/1024        2229 ns/op       459.36 MB/s\nBenchmarkSum256/65536     133505 ns/op       490.89 MB/s\nBenchmarkWrite              2022 ns/op       506.36 MB/s\nBenchmarkXOF                1914 ns/op       534.98 MB/s\n```\n\n## Shortcomings\n\nThere is no assembly routine for single-block compressions. This is most\nnoticeable for ~1KB inputs.\n\nEach assembly routine inlines all 7 rounds, causing thousands of lines of\nduplicated code. Ideally the routines could be merged such that only a single\nroutine is generated for AVX-512 and AVX2, without sacrificing too much\nperformance.\n"
    }
  },
  {
    "name": "lukechampine/geiger",
    "stars": 276,
    "description": "A Geiger counter for allocations",
    "languages_breakdown": {
      "Go": 2038
    },
    "files": {
      "go.mod": "module github.com/lukechampine/geiger\n\ngo 1.15\n\nrequire github.com/faiface/beep v1.0.2\n",
      "README.md": "geiger\n------\n\n[![GoDoc](https://godoc.org/github.com/lukechampine/geiger?status.svg)](https://godoc.org/github.com/lukechampine/geiger)\n[![Go Report Card](http://goreportcard.com/badge/github.com/lukechampine/geiger)](https://goreportcard.com/report/github.com/lukechampine/geiger)\n\n```\ngo get lukechampine.com/geiger\n```\n\nInspired by [this tweet](https://twitter.com/laserallan/status/1159571592332087296).\nJust call `go geiger.Count()` at the top of your `main` function. Don't worry, if\nyou start tasting metal, you're probably just delusional.\n\nThis package is in a pretty unpolished state. ~~First of all, it emits a constant\ntone, not a series of clicks like a real Geiger counter, because I couldn't\nfigure out how to get the `beep` package to click the way I wanted.~~ (EDIT: [fixed, thanks @klauspost!](https://github.com/lukechampine/geiger/pull/1)) Second, the\npackage itself incurs a non-zero number of allocations per second (~100 on\nMacOS, presumably different on other platforms) which throws off the reading.\nThird, it's completely unconfigurable: you can't adjust the \"sensitivity,\" and\nyou can only measure the number of objects allocated per second (as opposed to,\ne.g., the number of *bytes* allocated per second).\n\nStill, I think the general idea of \"use sound to alert the programmer that\nthey're doing something stupid\" has merit. If enough people agree, maybe we can\nwork together to refine it into an actually useful tool.\n\n### Troubleshooting\n\nThis package uses [beep](https://github.com/faiface/beep) to play audio. If you\ncan't hear anything, please check the `beep` issue tracker (and open issues there,\nif necessary) rather than on this repo. I know basically nothing about audio\ninterfaces, so I'm not going to be able to help you!\n"
    }
  }
]