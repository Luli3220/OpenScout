[
  {
    "name": "klmr/box",
    "stars": 942,
    "description": "Write reusable, composable and modular R code",
    "languages_breakdown": {
      "R": 215388,
      "Makefile": 6156,
      "C": 5685,
      "CSS": 2251,
      "Shell": 1841,
      "JavaScript": 101
    },
    "files": {
      "README.md": "<!-- README.md is generated from README.rmd. Please edit that file instead! -->\n\n\n\n# box <img src=\"man/figures/logo.png\" align=\"right\" alt=\"\" width=\"120\"/>\n\n> Write Reusable, Composable and Modular R Code\n\n\n[![CRAN status badge](https://www.r-pkg.org/badges/version/box)][CRAN]\n[![R-universe status badge](https://klmr.r-universe.dev/badges/box)][R-universe]\n\n<div id='tldr'>\n\n* [Get started][]\n* [Documentation][]\n* [Contributing][]\n* [Frequently asked questions][FAQ]\n\n</div>\n\n## üì¶ Installation\n\n‚Äòbox‚Äô can be installed from CRAN:\n\n\n``` r\ninstall.packages('box')\n```\n\nAlternatively, the current development version can be installed from [R-universe][] (note that it *cannot* be installed directly from GitHub!):\n\n\n``` r\ninstall.packages('box', repos = 'https://klmr.r-universe.dev')\n```\n\n## ü•ú Usage in a nutshell\n\n‚Äòbox‚Äô allows organising R code in a more modular way, via two mechanisms:\n\n1. It enables *writing modular code* by treating files and folders of R code as independent (potentially nested) modules, without requiring the user to wrap reusable code into packages.\n2. It provides a new syntax to import reusable code (both from packages and modules) that is more powerful and less error-prone than `library` by allowing explicit control over what names to import, and by restricting the scope of the import.\n\n### Reusable code modules\n\nCode doesn‚Äôt have to be wrapped into an R package to be reusable. With ‚Äòbox‚Äô, regular R files are reusable **R modules** that can be used elsewhere. Just put the **export directive** `#' @export` in front of names that should be exported, e.g.:\n\n```r\n#' @export\nhello = function (name) {\n    message('Hello, ', name, '!')\n}\n\n#' @export\nbye = function (name) {\n    message('Goodbye ', name, '!')\n}\n```\n\nExisting R scripts without `@export` directives can also be used as modules. In that case, all names inside the file will be exported, unless they start with a dot (`.`).\n\nSuch modules can be stored in a central **module search path** (configured via `options('box.path')`) analogous to the R package library, or locally in individual projects. Let‚Äôs assume the module we just defined is stored in a file `hello_world.r` inside a directory `mod`, which is inside the module search path. Then the following code imports and uses it:\n\n\n``` r\nbox::use(mod/hello_world)\n\nhello_world$hello('Ross')\n#> Hello, Ross!\n```\n\nModules are a lot like packages. But they are easier to write and use (often without requiring any set-up), and they offer some other nice features that set them apart from packages (such as the ability to be nested hierarchically).\n\nFor more information on writing modules refer to the *[Get started][]* vignette.\n\n### Loading code\n\n`box::use` provides a **universal import declaration**. It works for packages just as well as for modules. In fact, ‚Äòbox‚Äô completely replaces the base R `library` and `require` functions. `box::use` is more explicit, more flexible, and less error-prone than `library`. At its simplest, it provides a dir\n... (truncated)"
    }
  },
  {
    "name": "klmr/named-operator",
    "stars": 507,
    "description": "Named operators for C++",
    "languages_breakdown": {
      "C++": 3937,
      "Makefile": 346
    },
    "files": {
      "README.md": "# Named operators\n\n## tl;dr\n\nThe following code is legal C++ and does exactly what you‚Äôd expect it to do.\n\n```c++\nauto result = \"Hello\" <repeat> 3 <join> \", \";\nstd::cout << result << '\\n';\n```\n\nOutput:\n\n```\nHello, Hello, Hello\n```\n\nThis project explains how.\n\n## Background\n\nNamed operators are (user-defined) operators which have names rather than symbols. Here‚Äôs Haskell:\n\n```haskell\nx = a `div` b\n```\n\nand [here‚Äôs R](http://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html):\n\n```R\nyup <- 4 %in% c(1, 2, 3, 4, 5)\n```\n\nIn fact, [C++ also has named operators](http://gcc.gnu.org/onlinedocs/cpp/C_002b_002b-Named-Operators.html) ‚Äì alternative tokens for the primary ones defined, in ¬ß2.6.\n\nBut those are fixed and not redefinable. Sure, you can `#define` your own names for tokens¬†‚Ä¶\n\n    #define PLUS +\n\nBut this has all the usual disadvantages of macros and limits you to the already existing binary operators. Until now.\n\nTake a look at this fully valid, macro-free, compiling and running C++ code:\n\n```c++\nint x = 42;\nint y = 23;\nauto z = x <divmod> y; // calculates { x / y, x % y }\n```\n\nYou want assignment operators? Not a problem:\n\n```c++\nvector<int> vec{ 1, 2, 3 };\nvec <append>= 4;\n// same as:\nvec = vec <append> 4;\n```\n\n## Definition\n\nOperators can be defined for any binary function-like object by calling `make_named_operator`:\n\n```c++\nauto divmod = make_named_operator(divmod_f);\n```\n\nwhere\n\n```c++\npair<int, int> divmod_f(int x, int y) {\n    return { x / y, x % y };\n}\n```\n\nOr, if you prefer functors (and yes, templates work just fine):\n\n```c++\nauto append = make_named_operator(append_t());\n```\n\nwith\n\n```c++\nstruct append_t {\n    template <typename T>\n    vector<T> operator ()(vector<T> const& vs, T const& v) const {\n        auto copy(vs);\n        copy.push_back(v);\n        return copy;\n    }\n};\n```\n\nAnd of course lambdas work as well:\n\n```c++\nauto in = make_named_operator(\n    [](int i, vector<int> const& x) {\n        return find(begin(x), end(x), i) != end(x);\n    });\n\n// ‚Ä¶\n\nbool result = 24 <in> vec;\n```\n\n## Design rationale & implementation\n\nOverloading operators with unconventional semantics generally frowned upon because it violates the user‚Äôs expectations (although it has [variously](http://www.boost.org/doc/libs/1_53_0/libs/assign/doc/index.html) been used [to great effect](http://boost-spirit.com)).\n\nFurthermore, the set of operators that can be created in this fashion is limited to a subset of the built-in operators.\n\nOn the other hand, using infix notation instead of function calls can undeniably make code more readable, especially when nesting lots of operations. Compare\n\n```c++\nauto result = contains(set_minus(set_minus(A, B), C), x);\n```\n\nand\n\n```c++\nauto result = x <in> (A <set_minus> B <set_minus> C);\n```\n\nOther languages have recognised and addressed this problem.\n\nSince C++ allows overloading operators for custom types, named operators can be implemented by simply sticking a place-holder object between two overloaded operators (\n... (truncated)"
    }
  },
  {
    "name": "klmr/cpp11-range",
    "stars": 314,
    "description": "Range-based for loops to iterate over a range of numbers or values",
    "languages_breakdown": {
      "C++": 8954,
      "Makefile": 108
    },
    "files": {
      "README.md": "## Re-imagining the `for` loop\n\nC++11 now knows two distinct types of `for` loops: the classic loop over an ‚Äúindex‚Äù and the range-based `for` loop which vastly simplifies the iteration over a range specified by a pair of iterators.\n\nBy contrast, Python knows only one loop type ‚Äì roughly equivalent to the range-based for loop. In fact, loops over indices are exceedingly rare, but made possible by the use of the `range` method:\n\n```python\nfor i in range(10):\n    print i\n```\n\nWhich does what it promises ‚Äì although Python version < 3.0 does the ‚Äúwrong‚Äù thing and actually instantiates the whole collection in memory at once; a remedy is `xrange` which yields values lazily as they are consumed by the loop.\n\nC++11 effortlessly allows the same but there is no standard library function to provide this. [Boost.Range][] provides *part* of the functionality via `irange` which only works on integers, and not for unlimited ranges (this will make sense in a second).\n\nThe header `range.hpp` provides a very basic implementation for this. It allows running the following code:\n\n```c++\nusing util::lang::range;\n\nfor (auto i : range(1, 5))\n    cout << i << \"\\n\";\n\nfor (auto u : range(0u))\n    if (u == 3u) break;\n    else         cout << u << \"\\n\";\n\nfor (auto c : range('a', 'd'))\n    cout << c << \"\\n\";\n\nfor (auto i : range(100).step(-3))\n    if (i < 90) break;\n    else        cout << i << \"\\n\";\n```\n\n`range` with a single argument deviates from the Python semantic and creates an endless loop, unless it‚Äôs interrupted manually. This is an interesting use-case that cannot be modelled in Python using `range`.\n\n## Iterating over container indices\n\nIn Python, the one-argument version of `range` is often used to iterate over the indices of a container via `range(len(container))`. Because that overload creates an infinite range in our C++ library, we cannot use this idiom.\n\nBut we can do better anyway. For those few cases where we actually want to iterate over a container‚Äôs indices, we just use the `indices` function:\n\n```c++\nusing util::lang::indices;\n\nstd::vector<int> x{1, 2, 3};\nfor (auto i : indices(x))\n    cout << i << '\\n';\n```\n\nThis works as expected for *any* type which has a member function `size() const` that returns some integral type. It also works with `initializer_list`s and C-style fixed-size arrays.<sup id=\"a1\">[1](#f1)</sup>\n\nAdding `.step(‚Ä¶)` to the end of either `range` or `indices` specifies a step size instead of the default, 1.\n\nThe construct works for arbitrary types which fulfil the interface requirements (incrementing, copying, equality comparison, default construction in the case of infinite ranges).\n\n**<sup id=\"f1\">1</sup>** This includes string literals, which are C-style strings that include null termination; this may lead to surprising results, because `indices(\"test\")` results in 0, 1, 2, 3, 4, whereas `indices(std::string{\"test\"})` results in 0, 1, 2, 3. [‚Ü©](#a1)\n\n## Performance (the cost of beauty)\n\nWhen compiling with optimisations enabled (and w\n... (truncated)"
    }
  }
]