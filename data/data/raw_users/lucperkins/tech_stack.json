[
  {
    "name": "lucperkins/colossus",
    "stars": 1044,
    "description": "Colossus — An example microservice architecture for Kubernetes using Bazel, Go, Java, Docker, Kubernetes, Minikube, Gazelle, gRPC, Prometheus, Grafana, and more",
    "languages_breakdown": {
      "Starlark": 16545,
      "Go": 9885,
      "Java": 5665,
      "Makefile": 1537,
      "C++": 1408
    },
    "files": {
      "README.md": "# Colossus — An example microservice architecture for Kubernetes powered by Bazel, Go, Java, Docker, and gRPC\n\nThis is an example project that combines several cloud native technologies that I really like and have been meaning to get working in a meaningful way:\n\n- The [Bazel](https://bazel.build) build tool\n- [Kubernetes](https://kubernetes.io) and [Minikube](https://kubernetes.io/docs/getting-started-guides/minikube/)\n- [Protocol Buffers](https://developers.google.com/protocol-buffers/) and [gRPC](https://grpc.io)\n- [Docker](https://docker.com)\n\nColossus is basically a microservice architecture consisting of three services:\n\n| Service                                                                                       | Where the code lives   | Language |\n| :-------------------------------------------------------------------------------------------- | :--------------------- | :------- |\n| An HTTP service that takes web requests. This is the entry point into the backend services.   | [`web`](web)           | Go       |\n| An authentication/authorization service                                                       | [`auth`](auth)         | Go       |\n| A \"data\" service that handles data requests                                                   | [`data`](data)         | Java     |\n| A \"user info\" service that doesn't do anything interesting yet, but it works and it's in C++! | [`userinfo`](userinfo) | C++      |\n\n## The services\n\nWhat do these services actually do?\n\n- The web service requires a `Password` header and a `String` header. The `Password` header is used for authentication and the `String` header is used as a data input. You need to make `POST` requests to the `/string` endpoint.\n- The auth service verifies the password passed to the web service. There is only one password that actually works: `tonydanza`. Use any other password and you'll get a `401 Unauthorized` HTTP error.\n- The data service handles words or strings that you pass to the web service using the `String` header. The data service simply capitalizes whatever you pass via that header and returns it.\n\n> Wait a second, these services don't do anything meaningful! Nope, they sure don't. But that's okay because the point of this project is to show you how to get the basic (yet not-at-all-trivial) plumbing to work. Colossus is a **boilerplate project** that's meant as a springboard to more complex and meaningful projects.\n\n## What's the point?\n\nGetting all of these technologies to work together was a real challenge. I had to dig through countless GitHub issues and dozens of example projects to make all these things work together. I'm offering this repo as a starter pack for other people with a Bazel monorepo targeting Kubernetes.\n\n## Running Colossus locally\n\nIn order to run Colossus locally, you'll need to run a local Docker registry. If your Docker daemon is started up, you can run the local registry like this:\n\n```bash\n$ docker run -d -p 5000:5000 --restart=always --name r\n... (truncated)"
    }
  },
  {
    "name": "lucperkins/rek",
    "stars": 384,
    "description": "An easy HTTP client for Go. Inspired by the immortal Requests.",
    "languages_breakdown": {
      "Go": 18190,
      "Nix": 671,
      "Makefile": 161,
      "Shell": 9
    },
    "files": {
      "go.mod": "module github.com/lucperkins/rek\n\ngo 1.23.0\n\ntoolchain go1.24.5\n\nrequire (\n\tgithub.com/stretchr/testify v1.7.1\n\tgolang.org/x/oauth2 v0.30.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20220521103104-8f96da9f5d5e // indirect\n)\n",
      "README.md": "# rek\n\n[![go.dev reference](https://img.shields.io/badge/go.dev-reference-007d9c?logo=gostyle=flat)](https://pkg.go.dev/mod/github.com/lucperkins/rek)\n\nAn easy HTTP client for [Go](https://golang.org) inspired by [Requests](https://requests.readthedocs.io/en/master/), plus all the Go-specific goodies you'd hope for in a client. Here's an example:\n\n```go\n// GET request\nres, _ := rek.Get(\"https://httpbin.org/get\")\n\nfmt.Println(res.StatusCode())\n\nbody, _ := rek.BodyAsString(res.Body())\n\nfmt.Println(body)\n\n// POST request\ntype Comment struct {\n    Username string `json:\"username\"`\n    Body     string `json:\"body\"`\n}\n\nres, _ := rek.Post(\"https://httpbin.org/post\",\n    rek.Json(Comment{Username: \"genesiskel\", Body: \"This movie sucked. Two thumbs down.\"}),\n    rek.Headers(map[string]string{\"My-Custom-Header\": \"foo,bar,baz\"}),\n    rek.BasicAuth(\"user\", \"pass\"),\n    rek.Timeout(5 * time.Second),\n)\n\nfmt.Println(res.StatusCode())\n\nbody, _ := rek.BodyAsString(res.Body())\nfmt.Println(body)\n```\n\n## Responses\n\nThe `Response` struct has the following methods:\n\n\nMethod | Description | Return type\n:------|:------------|:-----------\n`StatusCode()` | HTTP status code, e.g. 200, 400 | `int`\n`Body()` | The HTTP response body as a reader | [`io.ReadCloser`](https://pkg.go.dev/io?tab=doc#ReadCloser)\n`Headers()` | The response headers | `map[string]string`\n`Encoding()` | The content encoding of the response body, e.g. `gzip` | `[]string`\n`ContentType()` | The value of the `Content-Type` header | `string`\n`Raw()` | The unmodified [`*http.Response`](https://pkg.go.dev/net/http?tab=doc#Response) | [`*http.Response`](https://pkg.go.dev/net/http?tab=doc#Response)\n`Cookies()` | The cookies attached to the response | `[]*http.Cookie`\n`ContentLength()` | The length of the response | `int64`\n`Status()` | The status of the response, e.g. `200 OK` | `string`\n\n### HTTP response body\n\nKeep in mind that the HTTP response body **can only be read once**. This is one area in which rek does *not* directly correspond to the [Requests](https://requests.readthedocs.io/en/master/) API. And so this, for example, won't work the way you might want:\n\n```go\nres, _ := rek.Get(\"https://httpbin.org/get\")\n\nbs1, _ := ioutil.ReadAll(res.Body()) // Non-empty byte slice\n\nbs2, _ := ioutil.ReadAll(res.Body()) // Empty byte slice\n```\n\nIf you'd like to use the response body more than once, store it in a variable rather than re-accessing the body.\n\n### Helper methods\n\nThere are two simple helper methods for working with the response body:\n\nFunction | Return types\n:--------|:------------\n`BodyAsString(io.ReadCloser)` | `(string, error)`\n`BodyAsBytes(io.ReadCloser)` | `([]byte, error)`\n\nBear in mind the caveat mentioned above, that the request body can only be read once, still holds. Here are some examples:\n\n```go\nres, _ := rek.Get(\"https://httpbin.org/get\")\n\ns1, _ := rek.BodyAsString(res.Body()) // body is read here\n\ns2, _ := rek.BodyAsString(res.Body()) // s2 is an empty string\n```\n\n### Non-standard methods\n\nr\n... (truncated)"
    }
  },
  {
    "name": "lucperkins/rust-graphql-juniper-actix-diesel-postgres",
    "stars": 259,
    "description": "An example GraphQL server written in Rust",
    "languages_breakdown": {
      "Rust": 11457,
      "PLpgSQL": 1145,
      "Nix": 942,
      "Makefile": 239,
      "Procfile": 75,
      "Shell": 18
    },
    "files": {
      "Cargo.toml": "[package]\nname = \"todos\"\nversion = \"0.1.0\"\nauthors = [\"lucperkins <lucperkins@gmail.com>\"]\nedition = \"2018\"\n\n[dependencies]\nactix-rt = \"1.0.0\"\nactix-web = \"2.0.0\"\ndiesel = { version = \"1.4.3\", features = [\"postgres\", \"r2d2\"] }\ndotenv = \"0.15.0\"\nenv_logger = \"0.7.1\"\njuniper = \"0.14.2\"\nr2d2 = \"0.8.8\"\nserde_json = \"1.0.44\"\n",
      "docker-compose.yml": "services:\n \n  db:\n    image: postgres:latest\n    restart: always\n    environment:\n      POSTGRES_DB: todos\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: example\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n \nvolumes:\n  pgdata:\n",
      "README.md": "# Rust + GraphQL + Juniper + Diesel + Postgres + Actix\n\nYes, I know that this is a borderline absurd web stack for the ubiquitous TODO application but I had a *lot* of trouble getting this all to work. I started using these things for a more ambitious project and I'd love to spare you the trouble. So here's some basic boilerplate to get you up and running.\n\n## Components\n\nHere's what does what:\n\nComponent | Tool/lib\n:---------|:--------\nWeb server | [actix-web](https://github.com/actix/actix-web)\nDatabase | [PostgreSQL](https://postgresql.org)\nSQL engine | [Diesel](https://diesel.rs)\nGraphQL library | [Juniper](https://github.com/graphql-rust/juniper)\nGraphQL UI | [GraphQL Playground](https://github.com/prisma-labs/graphql-playground)\n\n## Run locally\n\n> Before you get started, make sure that you have [PostgreSQL](https://postgresql.org), [Rust](https://rust-lang.org), [Cargo](https://doc.rust-lang.org/cargo/), and the [Diesel](https://diesel.rs) CLI installed and that you have Postgres running somewhere.\n\n```bash\n# Fetch the repo\ngit clone https://github.com/lucperkins/rust-actix-diesel-postgres-juniper\ncd rust-actix-diesel-postgres-juniper\n\n# If you would like to run the postgres server in docker\ndocker compose up\n\n# Set up the database\ncp .env.example .env # Modify this file to match your Postgres installation\n\ndiesel setup\ndiesel migration run\n\ncargo run # could take a while!\n```\n\n> The `DATABASE_URL` can be any Postgres installation. For my purposes, I have it set to `postgres://localhost:5432/todos`.\n\nOnce the server is running, you can access the GraphQL Playground UI at http://localhost:4000/graphql.\n\n## Schema\n\nThe server implements the following GraphQL schema:\n\n```graphql\ntype Todo {\n  id: ID!\n  task: String!\n  done: Boolean!\n}\n\ninput CreateTodoInput {\n  task: String!\n  done: Boolean\n}\n\ntype Query {\n  allTodos: [Todo!]!\n  getTodoById(id: Int): Todo\n}\n\ntype Mutation {\n  createTodo(input: CreateTodoInput): Todo\n  markTodoAsDone(id: Int): Todo\n  markTodoAsNotDone(id: Int): Todo\n}\n\nschema {\n  Query\n  Mutation\n}\n```\n\n## Tour of the codebase\n\nFile | What it provides\n:----|:----------------\n[`context.rs`](./src/context.rs) | The GraphQL [context](https://graphql.org/learn/execution) that handles query execution\n[`data.rs`](./src/data.rs) | A `Todos` struct and some helper functions encapsulate the [Diesel](https://diesel.rs)-powered Postgres querying logic\n[`db.rs`](./src/db.rs) | The connection pool that handles the Postgres connection\n[`endpoints.rs`](./src/endpoints.rs) | The `/graphql` HTTP endpoint that makes GraphQL and the GraphQL Playground work\n[`graphql.rs`](./src/graphql.rs) | The `Query`, `Mutation`, and `Schema` objects that undergird the GraphQL interface\n[`lib.rs`](./src/lib.rs) | Just the standard `lib.rs`\n[`main.rs`](./src/main.rs) | [Actix](https://actix.rs) HTTP server setup\n[`models.rs`](./src/models.rs) | All of the data types used for querying Postgres and providing GraphQL results\n[`schema.rs`](./src/schema.rs) | The Die\n... (truncated)"
    }
  }
]