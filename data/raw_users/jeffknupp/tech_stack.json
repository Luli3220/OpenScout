[
  {
    "name": "jeffknupp/sandman",
    "stars": 2298,
    "description": "Sandman \"makes things REST\".",
    "languages_breakdown": {
      "Python": 273561,
      "HTML": 7345,
      "Batchfile": 1296,
      "Makefile": 503,
      "Shell": 363
    },
    "files": {
      "requirements.txt": "Flask==0.10.1\nFlask-HTTPAuth==2.2.1\nFlask-Admin==1.0.7\nFlask-SQLAlchemy==1.0\nJinja2==2.7.2\nMarkupSafe==0.19\nSQLAlchemy==0.9.4\nWTForms==1.0.5\nWerkzeug==0.9.4\nitsdangerous==0.24\nwsgiref==0.1.2\nclick==0.7\nsphinx-rtd-theme==0.1.6\n",
      "README.md": "This version is obsolete, please consider using https://github.com/jeffknupp/sandman2\n======================================================================================\n\n[![Build Status](https://travis-ci.org/jeffknupp/sandman.png?branch=develop)](https://travis-ci.org/jeffknupp/sandman)\n\n[![Coverage Status](https://coveralls.io/repos/jeffknupp/sandman/badge.png?branch=develop)](https://coveralls.io/r/jeffknupp/sandman?branch=develop)\n\n[![Gitter chat](https://badges.gitter.im/jeffknupp/sandman.png)](https://gitter.im/jeffknupp/sandman)\n\n[![Analytics](https://ga-beacon.appspot.com/UA-12615441-7/sandman/home)](https://github.com/jeffknupp/sandman)\n\n[![PyPI](http://img.shields.io/pypi/dm/sandman.svg)](http://img.shields.io/pypi/dm/sandman.svg)\n\n\nDiscuss\n-------\n\nLooking for a place to ask questions about sandman? Check out the <a href=\"https://groups.google.com/forum/#!forum/sandman-discuss\">sandman-discuss</a> and <a href=\"https://groups.google.com/forum/#!forum/sandman-users\">sandman-users</a> forums!\n \nDocumentation\n-------------\n\n[Sandman documentation](https://sandman.readthedocs.org/en/latest/)\n\n`sandman` \"makes things REST\". Have an existing database you'd like to expose via\na REST API? Normally, you'd have to write a ton of boilerplate code for\nthe ORM you're using, then integrate that into some web framework. \n\nI don't want to write boilerplate.\n\nHere's what's required to create a RESTful API service from an existing database using\n`sandman`:\n\n```bash\n$ sandmanctl sqlite:////tmp/my_database.db\n```\n\n*That's it.* `sandman` will then do the following:\n\n* connect to your database and introspect its contents\n* create and launch a REST API service\n* create an HTML admin interface\n* *open your browser to the admin interface*\n\nThat's right. Given a legacy database, `sandman` not only gives you a REST API,\nit gives you a beautiful admin page and *opens your browser to the admin page*.\nIt truly does everything for you.\n\nSupported Databases\n------------------\n\n`sandman`, by default, supports connections to the same set of databases as\n[SQLAlchemy](http://www.sqlalchemy.org). As of this writing, that includes:\n\n* MySQL (MariaDB)\n* PostgreSQL\n* SQLite\n* Oracle\n* Microsoft SQL Server\n* Firebird\n* Drizzle\n* Sybase\n* IBM DB2\n* SAP Sybase SQL Anywhere\n* MonetDB\n\nAuthentication\n--------------\n\nAs of version 0.9.3, `sandman` fully supports HTTP Basic Authentication! See the\ndocumentation for more details.\n\nBehind the Scenes\n-----------------\n\n`sandmanctl` is really just a simple wrapper around the following:\n\n```python\nfrom sandman import app\n\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///chinook'\n\nfrom sandman.model import activate\n\nactivate()\n\napp.run()\n```\n\n**You don't even need to tell `sandman` what tables your database contains.** \nJust point `sandman` at your database and let it do all the heavy lifting\n\nLet's start our new service and make a request. While we're at it, lets make use\nof `sandman`'s awesome filtering capability by specifying a \n... (truncated)",
      "README.rst": "sandman\n=======\n\n|Build Status|\n\n|Coverage Status|\n\n|Gitter chat|\n\n|Analytics|\n\n|PyPI|\n\nHomepage\n--------\n\nVisit the home of ``sandman`` on the web:\n`sandman.io <http://www.sandman.io>`__\n\nDiscuss\n-------\n\nLooking for a place to ask questions about sandman? Check out the\nsandman-discuss and sandman-users forums!\n\nDocumentation\n-------------\n\n`Sandman documentation <https://sandman.readthedocs.org/en/latest/>`__\n\n``sandman`` \"makes things REST\". Have an existing database you'd like to\nexpose via a REST API? Normally, you'd have to write a ton of\nboilerplate code for the ORM you're using, then integrate that into some\nweb framework.\n\nI don't want to write boilerplate.\n\nHere's what's required to create a RESTful API service from an existing\ndatabase using ``sandman``:\n\n.. code:: bash\n\n    $ sandmanctl sqlite:////tmp/my_database.db\n    \n**Use an absolute path to the database or a 'full' URI** such as:\n   - postgresql+psycopg2://scott:tiger@localhost/test\n   - sqlite+pysqlite:///relative/path/to/db.db\n\n\n*That's it.* ``sandman`` will then do the following:\n\n-  connect to your database and introspect its contents\n-  create and launch a REST API service\n-  create an HTML admin interface\n-  *open your browser to the admin interface*\n\nThat's right. Given a legacy database, ``sandman`` not only gives you a\nREST API, it gives you a beautiful admin page and *opens your browser to\nthe admin page*. It truly does everything for you.\n\nSupported Databases\n-------------------\n\n``sandman``, by default, supports connections to the same set of\ndatabases as `SQLAlchemy <http://www.sqlalchemy.org>`__. As of this\nwriting, that includes:\n\n-  MySQL (MariaDB)\n-  PostgreSQL\n-  SQLite\n-  Oracle\n-  Microsoft SQL Server\n-  Firebird\n-  Drizzle\n-  Sybase\n-  IBM DB2\n-  SAP Sybase SQL Anywhere\n-  MonetDB\n\nAuthentication\n--------------\n\nAs of version 0.9.3, ``sandman`` fully supports HTTP Basic\nAuthentication! See the documentation for more details.\n\nBehind the Scenes\n-----------------\n\n``sandmanctl`` is really just a simple wrapper around the following:\n\n.. code:: python\n\n    from sandman import app\n\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///chinook'\n\n    from sandman.model import activate\n\n    activate()\n\n    app.run()\n\n**You don't even need to tell ``sandman`` what tables your database\ncontains.** Just point ``sandman`` at your database and let it do all\nthe heavy lifting\n\nLet's start our new service and make a request. While we're at it, lets\nmake use of ``sandman``'s awesome filtering capability by specifying a\nfilter term:\n\n.. code:: zsh\n\n    > python runserver.py &\n    * Running on http://127.0.0.1:5000/\n\n    > curl GET \"http://localhost:5000/artists?Name=AC/DC\"\n\n.. code:: json\n\n    ...\n    {\n        \"resources\": [\n            {\n                \"ArtistId\": 1,\n                \"Name\": \"AC/DC\",\n                \"links\": [\n                    {\n                        \"rel\": \"self\",\n                        \"uri\": \"/artists/1\"\n                    }\n                ]\n  \n... (truncated)"
    }
  },
  {
    "name": "jeffknupp/sandman2",
    "stars": 2046,
    "description": "Automatically generate a RESTful API service for your legacy database. No code required!",
    "languages_breakdown": {
      "Python": 49770,
      "HTML": 3118,
      "Shell": 433,
      "Dockerfile": 367,
      "Makefile": 291
    },
    "files": {
      "requirements.txt": "Flask==1.1.2\nFlask-Admin==1.5.7\nFlask-SQLAlchemy==2.4.4\nSQLAlchemy==1.3.20\nWTForms==2.3.3\ncoverage==5.3\npytest==6.2.0\nFlask-Cors==3.0.9\npytest-cov==2.10.1\npytest-flask==1.1.0\nsix==1.15.0\nwcwidth==0.2.5\nWerkzeug==1.0.1\nWTForms==2.3.3\nzipp==3.4.0\n",
      "Dockerfile": "FROM python:3-alpine\n\nRUN apk add postgresql-dev musl libffi-dev musl-dev gcc\n\nCOPY start.sh /start.sh\n\nRUN pip install sandman2 psycopg2 pymysql\n\nENV PORT 80\n\nEXPOSE 80\n\nCMD [\"/start.sh\"]\n",
      "README.md": "# sandman2\n[![Build Status](https://travis-ci.com/jeffknupp/sandman2.svg?branch=master)](https://travis-ci.com/jeffknupp/sandman2)\n[![Documentation Status](https://readthedocs.org/projects/sandman2/badge/?version=latest)](https://sandman2.readthedocs.io/en/latest/?badge=latest)\n[![Coverage Status](https://coveralls.io/repos/jeffknupp/sandman2/badge.svg?branch=master&service=github)](https://coveralls.io/github/jeffknupp/sandman2?branch=master)\n\n[sandman2 documentation](http://sandman2.readthedocs.io/en/latest/)\n\n [ ~ Dependencies scanned by PyUp.io ~ ]\n\n`sandman2` automagically generates a RESTful API service from your existing database,\nwithout requiring you to write a line of code. Simply point `sandman2` to your\ndatabase, add salt for seasoning, and voila!, a fully RESTful API service with\nhypermedia support starts running, ready to accept HTTP requests.  \n\nThis is a big deal. It means every single database you interact with, from the\nSQLite database that houses your web browser's data up to your production\nPostgreSQL server can be endowed with a REST API and accessed programmatically,\nusing any number of HTTP client libraries available in *every* language.\n`sandman2` *frees your data*.\n\n**For developers:**\n\nImagine you're working for AnonymousCorp and need to access\nGroup Y's data, which is presented to you through some horrible API or GUI.\nWouldn't it be nice if you could just interact with that database through a REST\nAPI?\n\nMore than that, imagine if you could interact with the database through a REST\nAPI **and no one had to write any code**. Not you. Not Group Y. No one.\nThat means no boilerplate ORM code, no database\nconnection logic. Nothing. `sandman2` can be run as a command-line tool\n(`sandman2ctl`) that just takes your database information as parameters and\nconnects to it, introspects the schema, generates a RESTful API, and starts the server.\n\n## What Happened to Sandman (1)?\n\n[`sandman`](http://www.github.com/jeffknupp/sandman), the precursor to `sandman2`, is no longer being maintained. `sandman` had almost identical\nfunctionality but had an architecture that reflected the capabilities of the underlying ORM, SQLAlchemy. As of the `0.9` release, SQLAlchemy\nintroduced the `automap` construct. This fundamentally changed the way that `sandman` *could* interact with the underlying database in a\nway that greatly simplified things. All that was needed was the actual effort to rewrite `sandman` from scratch...\n\n`sandman2` has since surpassed the functionality of the original `sandman` and the latter should be considered deprecated/obsolete.\n\n## Quickstart\n\nInstall `sandman2` using `pip`: `$ pip install sandman2`. This provides the script\n`sandman2ctl`, which just takes the database URI string, described [here](https://docs.sqlalchemy.org/en/latest/core/engines.html). For example, to connect to a SQLite database in the same directory you're running the script, you would run:\n\n```bash\n$ sandman2ctl sqlite+pysqlite:///database_file_name\n```\n\n... (truncated)",
      "README.rst": "sandman2\n========\n\n|Build Status| |Documentation Status| |Coverage Status|\n\n`sandman2 documentation <http://sandman2.readthedocs.io/en/latest/>`__\n\n``sandman2`` automagically generates a RESTful API service from your\nexisting database, without requiring you to write a line of code. Simply\npoint ``sandman2`` to your database, add salt for seasoning, and voila!,\na fully RESTful API service with hypermedia support starts running,\nready to accept HTTP requests.\n\nThis is a big deal. It means every single database you interact with,\nfrom the SQLite database that houses your web browser’s data up to your\nproduction PostgreSQL server can be endowed with a REST API and accessed\nprogramatically, using any number of HTTP client libraries available in\n*every* language. ``sandman2`` *frees your data*.\n\n**For developers:**\n\nImagine you’re working for AnonymousCorp and need to access Group Y’s\ndata, which is presented to you through some horrible API or GUI.\nWouldn’t it be nice if you could just interact with that database\nthrough a REST API?\n\nMore than that, imagine if you could interact with the database through\na REST API **and no one had to write any code**. Not you. Not Group Y.\nNo one. That means no boilerplate ORM code, no database connection\nlogic. Nothing. ``sandman2`` can be run as a command-line tool\n(``sandman2ctl``) that just takes your database information as\nparameters and connects to it, introspects the schema, generates a\nRESTful API, and starts the server.\n\nWhat Happened to Sandman (1)?\n-----------------------------\n\n```sandman`` <http://www.github.com/jeffknupp/sandman>`__, the precursor\nto ``sandman2``, is no longer being maintained. ``sandman`` had almost\nidentical functionality but had an architecture that reflected the\ncapabilities of the underlying ORM, SQLAlchemy. As of the ``0.9``\nrelease, SQLAlchemy introduced the ``automap`` construct. This\nfundamentally changed the way that ``sandman`` *could* interact with the\nunderlying database in a way that greatly simplified things. All that\nwas needed was the actual effort to rewrite ``sandman`` from scratch…\n\nAfter wrestling with the idea for a while, I finally gave in and started\nthe rewrite project. ``sandman2`` is that project. While I’ll continue\nto support ``sandman`` in the nearterm, ``sandman2`` definitely\nrepresents the way forward.\n\n**NOTE**: ``sandman2`` is not yet at feature parity with the original\n``sandman``, but should be soon. Getting there is currently the top\npriority.\n\nQuickstart\n----------\n\nInstall ``sandman2`` using ``pip``: ``$ pip install sandman2``. This\nprovides the script ``sandman2ctl``, which just takes the database URI\nstring, described\n`here <https://docs.sqlalchemy.org/en/latest/core/engines.html>`__. For\nexample, to connect to a SQLite database in the same directory you’re\nrunning the script, you would run:\n\n.. code:: bash\n\n   $ sandman2ctl sqlite+pysqlite:///database_file_name\n\nTo connect to a PostgreSQL database, make sure you install a driver like\n``psycopg2\n... (truncated)"
    }
  },
  {
    "name": "jeffknupp/blug",
    "stars": 157,
    "description": "Because \"I just blogged about it\" is too difficult to say.",
    "languages_breakdown": {
      "CSS": 153994,
      "HTML": 73288,
      "Python": 26355,
      "JavaScript": 14908
    },
    "files": {
      "requirements.txt": "Jinja2>=2.6\nMarkdown>=2.2.0\nPyYAML>=3.10\nPygments>=1.5\n",
      "README.md": "# Blug #\n\n*Because \"I just blogged about it\" is too difficult to say*\n\n## Intro ##\n\nBlug is a static site generator for Markdown based blogs. It currently\nuses the Octopress based theme from www.jeffknupp.com, but this will change shortly.\nWhile Blug generates static pages, the ultimate purpose of Blug is to run as a standalone process capable of 'psuedo-dynamic' site\ninteraction. Today's blogs are static, so much so that static blog generation tools have become the new 'Create a Twitter Clone'\nfor tutorials topics. I envision Blug as an intelligent agent, a daemon able to dynamically regenerate\nyour site and insert content when triggered by external events. Stuff like dynamically re-generating a post to include a link\nto comments on your post on HackerNews or reddit when Blug sees this event has occurred. Or re-generating to scale back the included css/javascript when Blug sees your webserver is getting hammered. These are the kinds of things I'm interested in exploring.\n\n## Installation ##\nBlug currently requires no installation, though running ```python setup.py install``` \nwill create 'install' the blug.py script. You can also get it from pip using ```pip install blug```.\n\n## Usage ##\nEdit the ```config.yaml``` file with values appropriate for your site. They should be pretty self-explanatory.\nOnce done, place your posts in a directory called ```content``` (this is the default location Blug checks for\nposts). Each post follows the Octopress/Jekyll naming convention for posts: year-month-day-title-of-post-as-slug.\nOnce you've got everything set up, there are three components to the ```blug.py``` script.\n\n### Creating a New Post ###\n```python blug.py post 'How Javascript is Ruining a Generation of Programmers' ``` This will create a new post\nin your ```content``` directory with the appropriate filename and yaml front matter. \n\n### Generating the Site ###\n```python blug.py generate``` This **deletes and regenerates the current generated content**. Run this whenever you\nmake a change to a post or after finishing a new one. The output in the ```generated``` directory is the complete site.\n\n### Viewing Your Site Locally ###\n```python blug.py serve <port> <host> <path>``` This starts a webserver locally to allow you to preview your site. Use\n```generated``` as the ```path``` argument to serve files using your generated site as the root.\n\n## Coming Soon ##\nA number of features have either been committed or are in the process of being committed\n\n* **Live Markdown Post Editing**- Start up the included webserver and navigate to host:port/create to\ncreate a new post with live Markdown translation. In the left pane you enter normal Markdown test. The right\npane is updated with the translated HTML in real time. No more regenerating your entire site just to see if you\nremembered how to do a nested list in Markdown.\n\n* **Git(hub)/Dropbox Integration**- Automatically deploy new posts and changes to your blog on the back of commits\nto your local git repository\n... (truncated)"
    }
  }
]