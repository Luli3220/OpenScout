[
  {
    "name": "emoon/minifb",
    "stars": 1153,
    "description": "MiniFB is a small cross platform library to create a frame buffer that you can draw pixels in",
    "languages_breakdown": {
      "C": 382162,
      "Objective-C": 85245,
      "C++": 26230,
      "CMake": 16023,
      "Shell": 6753,
      "HTML": 3821,
      "Lua": 3237
    },
    "files": {
      "README.md": "# MiniFB\n\nMiniFB (Mini FrameBuffer) is a small cross platform library that makes it easy to render (32-bit) pixels in a window.\n\n## Quick Start\n\nAn example is the best way to show how it works:\n\n```c\nstruct mfb_window *window = mfb_open_ex(\"my display\", 800, 600, WF_RESIZABLE);\nif (!window)\n    return 0;\n\nbuffer = (uint32_t *) malloc(800 * 600 * 4);\n\ndo {\n    int state;\n\n    // TODO: add some fancy rendering to the buffer of size 800 * 600\n\n    state = mfb_update_ex(window, buffer, 800, 600);\n\n    if (state < 0) {\n        window = NULL;\n        break;\n    }\n} while(mfb_wait_sync(window));\n```\n\n### How it works\n\n1. First the application creates a **window** calling **mfb_open** or **mfb_open_ex**.\n2. Next it's the application responsibility to allocate a buffer to work with.\n3. Next calling **mfb_update** or **mfb_update_ex** the buffer will be copied over to the window and displayed. If this function return a value lower than 0 the window will have been destroyed internally and cannot be used anymore.\n4. Last the code waits to synchronize with the monitor calling **mfb_wait_sync**.\n\n**Note:** By default, if ESC key is pressed, **mfb_update** / **mfb_update_ex** will return -1 (and the window will have been destroyed internally).\n\nSee <https://github.com/emoon/minifb/blob/master/tests/noise.c> for a complete example.\n\n## Supported Platforms\n\n| Platform | Backends | Status |\n|----------|----------|--------|\n| **Windows** | GDI, OpenGL | Fully supported |\n| **macOS** | Cocoa, Metal | Fully supported |\n| **Linux/Unix** | X11, Wayland | Fully supported (X11), Some issues (Wayland) |\n| **iOS** | Metal | Beta |\n| **Android** | Native | Beta |\n| **Web** | WASM | Beta |\n| **DOS** | DJGPP | Beta |\n\nMiniFB has been tested on Windows, macOS, Linux, iOS, Android, web, and DOSBox-x. Compatibility may vary depending on your setup. Currently, the library does not perform any data conversion if a proper 32-bit display cannot be created.\n\n## Features\n\n- ✓ Window creation and management\n- ✓ Event callbacks (keyboard, mouse, window lifecycle)\n- ✓ Direct window state queries\n- ✓ Per-window custom data\n- ✓ Built-in timers and FPS control\n- ✓ C and C++ interfaces\n- ✓ Cursor control\n\n## API Reference\n\n### Window Management\n\n```c\n// Create and manage windows\nstruct mfb_window * mfb_open(const char *title, unsigned width, unsigned height);\nstruct mfb_window * mfb_open_ex(const char *title, unsigned width, unsigned height, unsigned flags);\nvoid                mfb_close(struct mfb_window *window);\n\n// Update and synchronization\nmfb_update_state    mfb_update(struct mfb_window *window, void *buffer);\nmfb_update_state    mfb_update_ex(struct mfb_window *window, void *buffer, unsigned width, unsigned height);\nmfb_update_state    mfb_update_events(struct mfb_window *window);\nbool                mfb_wait_sync(struct mfb_window *window);\n\n// Viewport control\nbool                mfb_set_viewport(struct mfb_window *window, unsigned offset_x, unsigned offset_y, unsigned width, unsig\n... (truncated)"
    }
  },
  {
    "name": "emoon/rust_minifb",
    "stars": 1153,
    "description": "Cross platfrom window and framebuffer crate for Rust",
    "languages_breakdown": {
      "Rust": 271539,
      "Objective-C": 58204,
      "C": 7720
    },
    "files": {
      "Cargo.toml": "[package]\nname = \"minifb\"\nversion = \"0.28.0\"\nlicense = \"MIT OR Apache-2.0\"\nauthors = [\"Daniel Collin <daniel@collin.com>\"]\ndescription = \"Cross-platform window setup with optional bitmap rendering\"\nkeywords = [\"windowing\", \"window\", \"framebuffer\"]\ncategories = [\"rendering\"]\nrepository = \"https://github.com/emoon/rust_minifb\"\ndocumentation = \"https://docs.rs/minifb/0.15/minifb\"\nbuild = \"build.rs\"\nedition = \"2018\"\nreadme = \"README.md\"\n\nexclude = [\"examples/resources/\"]\n\n[[example]]\nname = \"wasm\"\ncrate-type = [\"cdylib\"]\n\n[badges]\nmaintenance = { status = \"actively-developed\" }\n\n[dev-dependencies]\npng = \"0.17\"\nconsole_error_panic_hook = \"0.1.7\"\nweb-sys = { version = \"0.3.56\", features = [\n  \"Blob\",\n  \"CanvasRenderingContext2d\",\n  \"CssStyleDeclaration\",\n  \"Document\",\n  \"Element\",\n  \"Gamepad\",\n  \"GamepadButton\",\n  \"GamepadEvent\",\n  \"Headers\",\n  \"HtmlCanvasElement\",\n  \"HtmlImageElement\",\n  \"ImageData\",\n  \"Navigator\",\n  \"Node\",\n  \"Request\",\n  \"RequestInit\",\n  \"RequestMode\",\n  \"Response\",\n  \"Url\",\n  \"Window\",\n  \"console\",\n  'KeyboardEvent',\n  'MouseEvent',\n] }\nwasm-bindgen = { version = \"0.2.79\", features = [\"serde-serialize\"] }\n\n[build-dependencies]\ncc = \"1.0\"\n\n[dependencies]\nraw-window-handle = \"0.6\"\nweb-time = \"1.1\"\n\n[target.'cfg(windows)'.dependencies.winapi]\nversion = \"0.3.9\"\nfeatures = [\"winuser\", \"wingdi\", \"libloaderapi\", \"errhandlingapi\", \"fileapi\"]\n\n[features]\ndefault = [\"wayland\", \"x11\", \"dlopen\"]\ndlopen = [\"wayland-client/dlopen\"]\nx11 = [\"x11-dl\", \"libc\"]\nwayland = [\n  \"dlib\",\n  \"lazy_static\",\n  \"libc\",\n  \"tempfile\",\n  \"wayland-client\",\n  \"wayland-cursor\",\n  \"wayland-protocols\",\n]\n\n[target.'cfg(not(any(target_os = \"macos\", target_os = \"redox\", windows, target_arch=\"wasm32\")))'.dependencies]\nwayland-client = { version = \"0.29\", optional = true }\nwayland-protocols = { version = \"0.29\", features = [\n  \"client\",\n  \"unstable_protocols\",\n], optional = true }\nwayland-cursor = { version = \"0.29\", optional = true }\ntempfile = { version = \"3.3\", optional = true }\nx11-dl = { version = \"2.19.1\", optional = true }\nlibc = { version = \"0.2.107\", optional = true }\ndlib = { version = \"0.5\", optional = true }\nlazy_static = { version = \"1.0\", optional = true }\n\n\n[target.x86_64-unknown-redox.dependencies]\norbclient = \"0.3.20\"\n\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\njs-sys = \"0.3.56\"\nwasm-bindgen-futures = \"0.4.29\"\nserde = { version = \"1.0.136\", features = [\"derive\"] }\nserde_derive = \"1.0.123\"\nfutures = \"0.3.12\"\nconsole_error_panic_hook = \"0.1.7\"\n# The `web-sys` crate allows you to interact with the various browser APIs,\n# like the DOM.\nweb-sys = { version = \"0.3.56\", features = [\n  \"Blob\",\n  \"CanvasRenderingContext2d\",\n  \"CssStyleDeclaration\",\n  \"Document\",\n  \"Element\",\n  \"Gamepad\",\n  \"GamepadButton\",\n  \"GamepadEvent\",\n  \"Headers\",\n  \"HtmlCanvasElement\",\n  \"HtmlImageElement\",\n  \"ImageData\",\n  \"Navigator\",\n  \"Node\",\n  \"Request\",\n  \"RequestInit\",\n  \"RequestMode\",\n  \"Response\",\n  \"Url\",\n  \"Window\",\n  \"console\",\n  'KeyboardEvent',\n  'MouseEvent',\n] }\n# Th\n... (truncated)",
      ".github/workflows/ci.yml": "on: [push, pull_request]\n\nname: CI\n\njobs:\n  fmt:\n    runs-on: ubuntu-latest\n    # Steps represent a sequence of tasks that will be executed as part of the job.\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v3\n\n      - name: Setup Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          components: rustfmt\n          override: true\n\n      - name: Check Format\n        run: cargo fmt -- --check\n\n  build_and_test:\n    name: Test\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macOS-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - if: matrix.os == 'ubuntu-latest'\n        run: sudo apt install libwayland-cursor0 libxkbcommon-dev libwayland-dev\n      - uses: actions/checkout@v2\n      - name: Build\n        run: cargo build --verbose\n      - name: Run tests\n        run: cargo test --verbose\n      - name: Install wasm target\n        run: rustup target add wasm32-unknown-unknown\n      - name: Check wasm build\n        run: cargo check --target wasm32-unknown-unknown --no-default-features\n",
      "README.md": "[![Build Status](https://github.com/emoon/rust_minifb/workflows/CI/badge.svg)](https://github.com/emoon/rust_minifb/actions?workflow=CI)\n[![Crates.io](https://img.shields.io/crates/v/minifb.svg)](https://crates.io/crates/minifb)\n[![Documentation](https://docs.rs/minifb/badge.svg)](https://docs.rs/minifb)\n\nminifb is a cross platform library written in [Rust](https://www.rust-lang.org) and that makes it easy to setup a window and to (optional) display a 32-bit pixel buffer.  It also makes it easy to get input from keyboard and mouse. Notice that minifb is primary designed for prototyping and may not include all the features found in full window handling libraries.\nAn example is the best way to show how it works:\n\n[Changelog](https://github.com/emoon/rust_minifb/blob/master/CHANGELOG.md)\n\nUsage\n-----\n\n```toml\n# Cargo.toml\n[dependencies]\nminifb = \"0.28\"\n```\n\nExample\n-------\n\n```rust\nuse minifb::{Key, Window, WindowOptions};\n\nconst WIDTH: usize = 640;\nconst HEIGHT: usize = 360;\n\nfn main() {\n    let mut buffer: Vec<u32> = vec![0; WIDTH * HEIGHT];\n\n    let mut window = Window::new(\n        \"Test - ESC to exit\",\n        WIDTH,\n        HEIGHT,\n        WindowOptions::default(),\n    )\n    .unwrap_or_else(|e| {\n        panic!(\"{}\", e);\n    });\n\n    // Limit to max ~60 fps update rate\n    window.set_target_fps(60);\n\n    while window.is_open() && !window.is_key_down(Key::Escape) {\n        for i in buffer.iter_mut() {\n            *i = 0; // write something more funny here!\n        }\n\n        // We unwrap here as we want this code to exit if it fails. Real applications may want to handle this in a different way\n        window\n            .update_with_buffer(&buffer, WIDTH, HEIGHT)\n            .unwrap();\n    }\n}\n```\n\nStatus\n------\nCurrently macOS, Linux and Windows (64-bit and 32-bit) are the current supported platforms. X11 (Linux/FreeBSD/etc) support has been tested on Ubuntu (x64). Linux Wayland support is also available. Bug report(s) for other OSes/CPUs are welcome!\nNotice: That after 0.13 Redox hasn't been updated and some work is required to get that working again. PR are welcome.\n\nBuild instructions\n------------------\n\nOn Linux you may need to install these dependencies first:\n\n```\nsudo apt install libxkbcommon-dev libwayland-cursor0 libwayland-dev\n```\n\n```\ncargo build\ncargo run --example noise\n```\n\nThis will run the [noise example](https://github.com/emoon/rust_minifb/blob/master/examples/noise.rs)\n\n## License\n\nLicensed under either of\n\n * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)\n * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)\n\nat your option.\n\n### Contribution\n\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n"
    }
  },
  {
    "name": "emoon/ProDBG",
    "stars": 519,
    "description": "Debugging the way it's meant to be done",
    "languages_breakdown": {
      "C++": 1101546,
      "Lua": 708615,
      "C": 326121,
      "Rust": 123765,
      "CSS": 50314,
      "HTML": 16730,
      "Batchfile": 7276,
      "Python": 4540,
      "Shell": 416
    },
    "files": {
      "README.md": "![](/data/prodbg_logo.png)\n======\n\nProDBG is a new debugger under development that will support a variety of targets and operating systems. Currently it's in very early development and primary focusing on Linux as primary target.\n\n## Build status\n\n![Build status](https://github.com/emoon/ProDBG/workflows/CI/badge.svg)\n\n### Status\n\nAs the rewrite of ProDBG (to using Qt in C++) is currently under way no debugging is working currently as everything is being brought up again. At this time C++ will be used for the UI but backends will be able to use different languages (such as Rust) as a C API is provided for this.\n\n## Cloning the repository\n\nThe ProDBG repository contains submodules. Clone it with `git clone --recursive`. If you forgot to clone it recursively the first time, from within the cloned repository run `git submodule update --init --recursive`.\n\n## How to compile and build\n\nLatest stable version of **Rust** (1.36+) needs to be present on the system. We recommend using [rustup](https://www.rustup.rs/) to install and manage your Rust toolchain(s). There are also other ways to [install rustup](https://github.com/rust-lang-nursery/rustup.rs/#other-installation-methods). If you already have rustup installed but aren't on the latest stable Rust, you can simply run `rustup update`.\n\n### Prequisites\n\nProDBG requires [Qt](https://www.qt.io/) as it's used for the UI. Go and install the 5.7 version and pick the 64-bit version for your system.\nYou also need to set three env variables: **QT5_LIB, QT5_BIN, QT5_INC** in order to build the code. See more details for each platform.\n## macOS\n\n### Prequisites\n\nBuilding the code on macOS requires that **Clang** is installed on your system. The easiest way to do this is to get Xcode and install the commandline tools.\n\n### Rustup\nRun: `rustup install stable-x86_64-apple-darwin` or `rustup override add stable-x86_64-apple-darwin`\n\n### Build\nRun: `scripts/mac_build_debug.sh`\n\n### Output\nThe main execeutable is located at: `t2-output/macosx-clang-debug-default/ProDBG.app/Content/MacOS/prodbg`\n\n## Windows\n\n### Prequisites\nOn Windows Visual Studio 2017 or later is required (2012 or earlier will not work as parts of the code uses C99)\n\n### Env variables\n\nSomething similar to this\n\n```\nQT5_LIB=C:\\Qt\\5.12.4\\msvc2017_64\\lib\nQT5_BIN=C:\\Qt\\5.12.4\\msvc2017_64\\bin\nQT5_INC=C:\\Qt\\5.12.4\\msvc2017_64\\include\n```\n\n### Rustup\n`rustup install stable-x86_64-pc-windows-msvc` or `rustup override add stable-x86_64-pc-windows-msvc`\n\n### Build\nRun: `scripts\\vcvarsx86_amd64.bat` and then `scripts\\win64_build_debug.cmd`\n\n### Run\nRun: `t2-output\\win64-msvc-debug-default\\prodbg.exe`\n\n## Linux\n\n### Prequisites\nBuilding the code on Linux will require some prerequisites to be installed. Which prerequisites depends on the distribution being used.\n\nFor Ubuntu you can use the following:\n```\nsudo apt-get update\nsudo apt-get install -y libx11-dev libgl1-mesa-dev libgtk-3-dev pkg-config qt515base\n```\n\nProDBG uses Tundra to build the project the proj\n... (truncated)"
    }
  }
]