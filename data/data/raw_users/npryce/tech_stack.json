[
  {
    "name": "npryce/adr-tools",
    "stars": 5173,
    "description": "Command-line tools for working with Architecture Decision Records",
    "languages_breakdown": {
      "Shell": 20445,
      "Makefile": 869
    },
    "files": {
      "README.md": "ADR Tools\n=========\n\nA command-line tool for working with a log of [Architecture Decision Records][ADRs] (ADRs).\n\n[![Build Status](https://travis-ci.org/npryce/adr-tools.svg?branch=master)](https://travis-ci.org/npryce/adr-tools)\n\nQuick Start\n-----------\n\n[Install ADR Tools](INSTALL.md).\n\nUse the `adr` command to manage ADRs.  Try running `adr help`.\n\nADRs are stored in a subdirectory of your project as Markdown files. \nThe default directory is `doc/adr`, but you can specify the directory\nwhen you initialise the ADR log.\n\n1. Create an ADR directory in the root of your project:\n\n        adr init doc/architecture/decisions\n\n    This will create a directory named `doc/architecture/decisions` \n    containing the first ADR, which records that you are using ADRs\n    to record architectural decisions and links to \n    [Michael Nygard's article on the subject][ADRs].\n\n2. Create Architecture Decision Records\n\n        adr new Implement as Unix shell scripts\n\n    This will create a new, numbered ADR file and open it in your\n    editor of choice (as specified by the VISUAL or EDITOR environment\n    variable).\n\n    To create a new ADR that supercedes a previous one (ADR 9, for example),\n    use the -s option.\n\n        adr new -s 9 Use Rust for performance-critical functionality\n\n    This will create a new ADR file that is flagged as superceding\n    ADR 9, and changes the status of ADR 9 to indicate that it is\n    superceded by the new ADR.  It then opens the new ADR in your\n    editor of choice.\n    \n3. For further information, use the built in help:\n\n        adr help\n\n\nSee the [tests](tests/) for detailed examples.\n\nThe decisions for this tool are recorded as [architecture decision records in the project repository](doc/adr/). \n\n[ADRs]: http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions\n"
    }
  },
  {
    "name": "npryce/hamkrest",
    "stars": 343,
    "description": "Hamcrest for Kotlin",
    "languages_breakdown": {
      "Kotlin": 56770,
      "Shell": 485
    },
    "files": {
      "README.md": "HamKrest - Hamcrest for Kotlin\n==============================\n\nA reimplementation of Hamcrest to take advantage of [Kotlin](https://kotlinlang.org/) language features.\n\n[![Kotlin](https://img.shields.io/badge/kotlin-1.3.11-blue.svg)](http://kotlinlang.org)\n[![Build Status](https://travis-ci.org/npryce/hamkrest.svg?branch=master)](https://travis-ci.org/npryce/hamkrest)\n[![Maven Central](https://img.shields.io/maven-central/v/com.natpryce/hamkrest.svg)](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.natpryce%22%20AND%20a%3A%22hamkrest%22)\n\nNote: as of version 1.4.0.0, you must add kotlin-reflect to the classpath to use HamKrest's reflective features.\n\n\nWhen working in Kotlin, Hamkrest provides these benefits over using the Java Hamcrest library:\n\n * Kotlin's type system means that developers don't have to worry about getting the variance of generic signatures right.  Variance is defined on the abstract Matcher type and Kotlin makes sure composition and subtyping work together the way you expect.\n \n * Syntactic sugar. You can negate a matcher with the ! operator and compose matchers with infix `and` and `or` functions:\n\n    ``` kotlin\n    import com.natpryce.hamkrest.assertion.assert\n          \n    ...\n          \n    assertThat(\"xyzzy\", startsWith(\"x\") and endsWith(\"y\") and !containsSubstring(\"a\"))\n    ```\n    \n * Easier to extend. You can convert named unary predicates into matchers.\n\n    ``` kotlin\n    val isBlank = Matcher(String::isBlank)\n    \n    assertThat(input, isBlank)\n    ```\n\n   As a shortcut, you can pass named functions to the `assertThat`, `and`, `or` and many other functions that take a matcher.\n\n    ``` kotlin\n    assertThat(input, String::isBlank)\n    ```\n\n   You can also convert a named binary predicate and the second argument to a matcher for first argument, which works well for extension methods.\n\n    ``` kotlin\n    fun String.hasLength(n: Int): Boolean = this.length == n\n\n    val isTheRightLength = Matcher(String::hasLength, 8)\n\n    assertThat(secretCode, isTheRightLength)\n    ```\n\n   You can use function and property references to match features of a value:\n\n   ``` kotlin\n   val isLongEnough = has(String::length, greaterThan(8))\n\n   assertThat(password, isLongEnough)\n   ```\n\n   All of these shortcuts produce good, human-readable diagnostics.\n\n   You can customise how diagnostics are generated by creating a project-specific `assert` object.\n\n\n## More documentation\n\n[More detailed documentation of specific library features is in the docs/ directory](docs/).\n"
    }
  },
  {
    "name": "npryce/konfig",
    "stars": 285,
    "description": "Simple config properties API for Kotlin",
    "languages_breakdown": {
      "Kotlin": 57361,
      "Shell": 485
    },
    "files": {
      "README.md": "# Konfig - A Type Safe Configuration API for Kotlin\n\n[![Kotlin](https://img.shields.io/badge/kotlin-1.0.0-blue.svg)](http://kotlinlang.org)\n[![Build Status](https://travis-ci.org/npryce/konfig.svg?branch=master)](https://travis-ci.org/npryce/konfig)\n[![Maven Central](https://img.shields.io/maven-central/v/com.natpryce/konfig.svg)](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.natpryce%22%20AND%20a%3A%22konfig%22)\n\nKonfig provides an extensible, type-safe API for configuration\nproperties gathered from multiple sources — built in resources, system\nproperties, property files, environment variables, command-line\narguments, etc.\n\nA secondary goal of Konfig is to make configuration \"self explanatory”.\n\nMisconfiguration errors are reported with the location and “true name”\nof the badly configured property. E.g. a program may look up a key\ndefined as `Key(\"http.port\", intType)`. At runtime, it will be parsed\nfrom an environment variable named `HTTP_PORT`. So the error message\nreports the name of the environment variable, so that the user can\neasily find and fix the error.\n\nConfiguration can be inspected and listed.  For example, it can be\nexposed by HTTP to a network management system to help site\nreliability engineers understand the current configuration of a\nrunning application.\n\n\n\nGetting Started\n---------------\n\nTo get started, add `com.natpryce:konfig:<version>` as a dependency, import `com.natpryce.konfig.*` and then:\n\n1. Define typed property keys\n\n    ```kotlin\n    val server_port = Key(\"server.port\", intType)\n    val server_host = Key(\"server.host\", stringType)\n    ```\n\n2. Build a Configuration object that loads properties:\n\n    ```kotlin\n    val config = systemProperties() overriding\n                 EnvironmentVariables() overriding\n                 ConfigurationProperties.fromFile(File(\"/etc/myservice.properties\")) overriding\n                 ConfigurationProperties.fromResource(\"defaults.properties\")\n    ```\n\n3. Define some properties.  For example, in `defaults.properties`:\n\n    ```properties\n    server.port=8080\n    server.host=0.0.0.0\n    ```\n    \n4. Look up properties by key. They are returned as typed values, not strings, and so can be used directly:\n\n    ```kotlin\n    val server = Server(config[server_port], config[server_host])\n    server.start()\n    ```\n\nKonfig can load properties from:\n\n* Java property files and resources\n* Java system properties\n* Environment variables\n* Hard-coded maps (with convenient syntax)\n* Command-line parameters (with long and short option syntax)\n\nKonfig can easily be extended with new property types and sources of configuration data.\n\nKonfig can report where configuration properties are searched for and where they were found.\n\n# Naming of Properties\n\nKonfig's Configuration objects expect property names to follow Java property name conventions: dots to represent hierarchy, lower-case identifiers within the hierarchy, hyphens to separate words in those identifiers. \n\nFor example: `servers.file-stora\n... (truncated)"
    }
  }
]