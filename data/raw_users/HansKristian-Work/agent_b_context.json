{
  "username": "HansKristian-Work",
  "agent_b_context": "\n=== PR #3692 in baldurk/renderdoc (Stars: 10252) ===\nFile: renderdoc/driver/vulkan/wrappers/vk_descriptor_funcs.cpp\nPatch:\n@@ -3452,9 +3452,9 @@ void WrappedVulkan::vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInf\n           dstRecord = GetRecord(pDescriptorInfo->data.pSampledImage->imageView);\n \n           DescriptorUniquenessKey descKey(\n-              m_IgnoreLayoutForDescriptors\n-                  ? VK_IMAGE_LAYOUT_UNDEFINED\n-                  : pDescriptorInfo->data.pCombinedImageSampler->imageLayout);\n+              m_IgnoreLayoutForDescriptors ? VK_IMAGE_LAYOUT_UNDEFINED\n+                                           : pDescriptorInfo->data.pCombinedImageSampler->imageLayout,\n+              pDescriptorInfo->type);\n \n           // this is internally locked\n           if(!dstRecord->resInfo->AddDescriptor(descKey))\n@@ -3523,7 +3523,8 @@ void WrappedVulkan::vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInf\n \n           dstRecord = GetResourceManager()->GetResourceRecord(id);\n \n-          DescriptorUniquenessKey descKey(offs, pDescriptorInfo->data.pUniformBuffer->range, fmt);\n+      \n... (truncated)\n\nFile: renderdoc/replay/replay_controller.cpp\nPatch:\n@@ -2327,7 +2327,7 @@ void ReplayController::FetchPipelineState(uint32_t eventId)\n \n     // if the last range is contiguous with this access, append this access as a new range to query\n     if(!ranges.empty() && ranges.back().descriptorSize == acc.byteSize &&\n-       ranges.back().offset + ranges.back().descriptorSize == acc.byteOffset &&\n+       ranges.back().offset + ranges.back().count * ranges.back().descriptorSize == acc.byteOffset &&\n        ranges.back().type == acc.type)\n     {\n       ranges.back().count++;\n\n\n=== PR #3676 in baldurk/renderdoc (Stars: 10252) ===\nFile: qrenderdoc/Windows/BufferViewer.cpp\nPatch:\n@@ -6413,10 +6413,10 @@ void BufferViewer::exportData(const BufferExport &params)\n             ResourceId buff = m_BufferID;\n \n             static const uint64_t maxChunkSize = 4 * 1024 * 1024;\n-            for(uint64_t byteOffset = m_ByteOffset; byteOffset < m_ByteSize;\n+            for(uint64_t byteOffset = m_ByteOffset; byteOffset < m_ByteSize + m_ByteOffset;\n                 byteOffset += maxChunkSize)\n             {\n-              uint64_t chunkSize = qMin(m_ByteSize - byteOffset, maxChunkSize);\n+              uint64_t chunkSize = qMin(m_ByteOffset + m_ByteSize - byteOffset, maxChunkSize);\n \n               // it's fine to block invoke, because this is on the export thread\n               m_Ctx.Replay().BlockInvoke([buff, f, byteOffset, chunkSize](IReplayController *r) {\n\n\n=== PR #2561 in KhronosGroup/SPIRV-Cross (Stars: 2326) ===\nFile: spirv_msl.cpp\nPatch:\n@@ -11091,7 +11091,7 @@ void CompilerMSL::emit_atomic_func_op(uint32_t result_type, uint32_t result_id,\n \t\t\t}\n \n \t\t\texp += join(image_expr, \".\", op, \"(\");\n-\t\t\tif (ptr_type.storage == StorageClassImage && res_type->image.arrayed)\n+\t\t\tif (ptr_type.storage == StorageClassImage && (res_type->image.arrayed || res_type->image.dim == DimCube))\n \t\t\t{\n \t\t\t\tswitch (res_type->image.dim)\n \t\t\t\t{\n@@ -11100,13 +11100,21 @@ void CompilerMSL::emit_atomic_func_op(uint32_t result_type, uint32_t result_id,\n \t\t\t\t\t\texp += join(\"uint2(\", coord, \".x, 0), \", coord, \".y\");\n \t\t\t\t\telse\n \t\t\t\t\t\texp += join(coord, \".x, \", coord, \".y\");\n-\n \t\t\t\t\tbreak;\n \t\t\t\tcase Dim2D:\n \t\t\t\t\texp += join(coord, \".xy, \", coord, \".z\");\n \t\t\t\t\tbreak;\n+\t\t\t\tcase DimCube:\n+\t\t\t\t\tif (!msl_options.supports_msl_version(4, 0))\n+\t\t\t\t\t\tSPIRV_CROSS_THROW(\"Cannot do atomics on Cube textures before 4.0.\");\n+\n+\t\t\t\t\tif (res_type->image.arrayed)\n+\t\t\t\t\t\texp += join(coord, \".xy, \", coord, \".z % 6u, \", coord, \".z / 6u\");\n+\t\t\t\t\telse\n+\t\t\t\t\t\texp += join(coord, \n... (truncated)\n\nFile: test_shaders.py\nPatch:\n@@ -117,6 +117,8 @@ def print_msl_compiler_version():\n         pass\n \n def path_to_msl_standard(shader):\n+    if '.msl4.' in shader:\n+        return '-std=metal4.0'\n     if '.msl32.' in shader:\n         return '-std=metal3.2'\n     if '.msl31.' in shader:\n@@ -157,9 +159,11 @@ def path_to_msl_standard(shader):\n             return '-std=macos-metal1.2'\n \n def path_to_msl_standard_cli(shader):\n-    if '.msl32.' in shader:\n+    if '.msl4.' in shader:\n+        return '40000'\n+    elif '.msl32.' in shader:\n         return '30200'\n-    if '.msl31.' in shader:\n+    elif '.msl31.' in shader:\n         return '30100'\n     elif '.msl3.' in shader:\n         return '30000'\n@@ -181,6 +185,13 @@ def path_to_msl_standard_cli(shader):\n ignore_win_metal_tool = False\n def validate_shader_msl(shader, opt):\n     msl_path = reference_path(shader[0], shader[1], opt)\n+\n+    # The 4.0 compiler for Windows is outdated and broken, so we cannot rely on version checks either.\n+    cli_standard = path_to_msl_standard\n... (truncated)\n\n"
}