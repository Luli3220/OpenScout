[
  {
    "name": "memN0ps/eagle-rs",
    "stars": 572,
    "description": "Rusty Rootkit - Windows Kernel Rookit in Rust (Codename: Eagle)",
    "languages_breakdown": {
      "Rust": 93356
    },
    "files": {
      "Cargo.toml": "[workspace]\n\nmembers = [\n    \"client\",\n    \"driver\",\n    \"common\",\n]\n\n[profile.release]\nopt-level = 3",
      "README.md": "# Windows Kernel Rookit in Rust (Codename: Eagle)\n\nBlog: https://memn0ps.github.io/rusty-windows-kernel-rootkit/\n\n## Features (Development in progress)\n\n* Protect / unprotect process (Done)\n* Elevate to NT AUTHORITY\\\\SYSTEM and Enable all token privileges (Done)\n* Hide process (Done)\n* Hide driver (Done)\n* Enumerate loaded kernel modules (Done)\n* Enumerate / remove kernel callbacks\n  * PsSetCreateProcessNotifyRoutine (Done)\n  * PsSetCreateThreadNotifyRoutine (Todo)\n  * PsSetLoadImageNotifyRoutine (Todo)\n  * CmRegisterCallbackEx (Todo)\n  * ObRegisterCallbacks (Todo)\n* DSE enable/disable (Done)\n\n## Usage\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe -h\nclient 0.1.0\n\nUSAGE:\n    client.exe <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    callbacks\n    driver\n    dse\n    help         Print this message or the help of the given subcommand(s)\n    process\n```\n\n```\nclient.exe-process\n\nUSAGE:\n    client.exe process --name <PROCESS> <--protect|--unprotect|--elevate|--hide>\n\nOPTIONS:\n    -e, --elevate           Elevate all token privileges\n    -h, --help              Print help information\n        --hide              Hide a process using Direct Kernel Object Manipulation (DKOM)\n    -n, --name <PROCESS>    Target process name\n    -p, --protect           Protect a process\n    -u, --unprotect         Unprotect a process\n```\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe callbacks -h\nclient.exe-callbacks\n\nUSAGE:\n    client.exe callbacks <--enumerate|--patch <PATCH>>\n\nOPTIONS:\n    -e, --enumerate        Enumerate kernel callbacks\n    -h, --help             Print help information\n    -p, --patch <PATCH>    Patch kernel callbacks 0-63\n```\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe dse -h\nclient.exe-dse\n\nUSAGE:\n    client.exe dse <--enable|--disable>\n\nOPTIONS:\n    -d, --disable    Disable Driver Signature Enforcement (DSE)\n    -e, --enable     Enable Driver Signature Enforcement (DSE)\n    -h, --help       Print help information\n```\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe driver -h\nclient.exe-driver\n\nUSAGE:\n    client.exe driver <--hide|--enumerate>\n\nOPTIONS:\n    -e, --enumerate    Enumerate loaded kernel modules\n    -h, --help         Print help information\n        --hide         Hide a driver using Direct Kernel Object Manipulation (DKOM)\n```\n\n## Enumerate and Patch Kernel Callbacks\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe callbacks --enumerate\nTotal Kernel Callbacks: 11\n[0] 0xffffbd8d3d2502df (\"ntoskrnl.exe\")\n[1] 0xffffbd8d3d2fe81f (\"cng.sys\")\n[2] 0xffffbd8d3db2bc8f (\"WdFilter.sys\")\n[3] 0xffffbd8d3db2bf8f (\"ksecdd.sys\")\n[4] 0xffffbd8d3db2c0df (\"tcpip.sys\")\n[5] 0xffffbd8d3f10705f (\"iorate.sys\")\n[6] 0xffffbd8d3f10765f (\"CI.dll\")\n[7] 0xffffbd8d3f10789f (\"dxgkrnl.sys\")\n[8] 0xffffbd8d3fa37cff (\"vm3dmp.sys\")\n[9] 0xffffbd8d3f97104f (\"peauth.sys\")\n[10] 0xffffbd8d43afb63f (\"Eagle.sys\")\n```\n\n```\nPS C:\\Users\\memn0ps\\Desktop> .\\client.exe callbacks --patch 10\n[+] Callback patc\n... (truncated)"
    }
  },
  {
    "name": "memN0ps/redlotus-rs",
    "stars": 560,
    "description": "Rusty Bootkit - Windows UEFI Bootkit in Rust (Codename: RedLotus)",
    "languages_breakdown": {
      "Rust": 103405
    },
    "files": {
      "Cargo.toml": "[workspace]\n\nmembers = [\n    \"bootkit\",\n    \"driver\",\n    \"client\",\n    \"testing123\",\n]\n\nresolver = \"2\"",
      "README.md": "# Windows UEFI Bootkit in Rust (Codename: RedLotus)\n\nIntroducing a Windows UEFI Bootkit in Rust designed to facilitate the manual mapping of a driver manual mapper before the kernel (`ntoskrnl.exe`) is loaded, effectively bypassing `Driver Signature Enforcement (DSE)`. This bootkit utilizes a UEFI runtime driver (`EFI_RUNTIME_DRIVER`) inspired by the work of [umap by @btbd](https://github.com/btbd/umap/). By employing a straightforward `.data` function pointer hook, the driver manual mapper enables the manual mapping of various Windows kernel drivers via a user-mode program. It is important to acknowledge that the communication method involving `xKdEnumerateDebuggingDevices` and `NtConvertBetweenAuxiliaryCounterAndPerformanceCounter`, originally shared by the legendary [@can1357](https://blog.can.ac/), may be flagged by anti-cheat systems. Hence, it is crucial to emphasize that this project serves as a Proof of Concept (PoC).\n\nIt is possible to manually map my [Windows kernel rootkit](https://github.com/memN0ps/rootkit-rs) or [Windows blue-pill hypervisor](https://github.com/memN0ps/hypervisor-rs) with minor modifications.\n\nThis project is inspired by the following:\n\n- Umap: https://github.com/btbd/umap/ (This project has been ported from C to Rust)\n- Bootlicker: https://github.com/realoriginal/bootlicker\n- BlackLotus: https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed/\n- ESPecter: https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/\n- UEFI-Bootkit: https://github.com/ajkhoury/UEFI-Bootkit/\n- EfiGuard: https://github.com/Mattiwatti/EfiGuard\n- Bootkitting Windows Sandbox: https://secret.club/2022/08/29/bootkitting-windows-sandbox.html\n- Rootkits and Bootkits: https://nostarch.com/rootkits\n\n## Description\n\nA bootkit can run code before the operating system and potentially inject malicious code into the kernel or load a malicious kernel driver by infecting the boot process and taking over the system's firmware or bootloader, effectively disabling or bypassing security protections. This tool can be used for game hacking and is a side project for those interested in fun, learning, malware research, and spreading security awareness. It also demonstrates that Rust can handle both low-level and high-level tasks. It's important to recognize the potential of Rust and not underestimate its power.\n\nThe image below shows how Legacy and UEFI boot works.\n\n![Legacy-and-UEFI-Boot](/images/Legacy-and-UEFI-Boot.png)\n**Figure 1. Comparison of the Legacy Boot flow (left) and UEFI boot flow (right) on Windows (Vista and newer) systems (Full Credits: [WeLiveSecurity](https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/))**\n\nThis diagram illustrates the structure and flow of the `redlotus.efi` UEFI bootkit and `redlotus.sys` Windows kernel driver manual mapper.\n\n![redlotus.drawio.png](./images/redlotus.drawio.png)\n\n## Install\n\n### [Install Rust](https://ww\n... (truncated)"
    }
  },
  {
    "name": "memN0ps/venom-rs",
    "stars": 353,
    "description": "Rusty Injection - Shellcode Reflective DLL Injection (sRDI) in Rust (Codename: Venom)",
    "languages_breakdown": {
      "Rust": 44095
    },
    "files": {
      "Cargo.toml": "[workspace]\nmembers = [\n    \"generate_shellcode\",\n    \"reflective_loader\",\n    \"payload\",\n    \"inject\"\n]\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[profile.release]\nopt-level = \"z\"     # Optimize for size.\nlto = true          # Enable Link Time Optimization\ncodegen-units = 1   # Reduce number of codegen units to increase optimizations.\npanic = \"abort\"     # Abort on panic\nstrip = true        # Automatically strip symbols from the binary.\n\n[profile.dev]\nopt-level = \"z\"     # Optimize for size.\nlto = true          # Enable Link Time Optimization\ncodegen-units = 1   # Reduce number of codegen units to increase optimizations.\npanic = \"abort\"     # Abort on panic\nstrip = true        # Automatically strip symbols from the binary.",
      "README.md": "# Shellcode Reflective DLL Injection (sRDI) in Rust (Codename: Venom)\n\nShellcode reflective DLL injection (sRDI) is a process injection technique that allows us to convert a given DLL into a position-independent code which can then be injected using our favourite shellcode injection and execution technique.\n\n## Features\n\n- The size of the reflective loader is approximately 4KB.\n\n- Does not release the memory that was allocated by the injector, nor does it remove any existing `RWX` permissions set by the user injector, if applicable.\n\n- Does not overwrite or erase the DOS or NT Headers of the newly allocated memory after/before resolving imports or rebasing image.\n\n- Applies protection settings for each section allocated by the `VirtualAlloc` function, and subsequently executes either DllMain or SayHello functions.\n\nWhat about `OPSEC`? Feel free to implement it yourself :)\n\n## Usage\n\n0). [Install Rust](https://www.rust-lang.org/tools/install)\n\n1). Build all of the projects\n\n```\ncargo build --release\n```\n\n2). Generate the shellcode.\n\n```\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs\\target\\release> .\\generate_shellcode.exe -h\nShellcode Reflective DLL Injection (sRDI)\n\nUsage: generate_shellcode.exe [OPTIONS] --loader <LOADER> --payload <PAYLOAD> --function <FUNCTION> --parameter <PARAMETER> --output <OUTPUT>\n\nOptions:\n      --loader <LOADER>        The reflective loader DLL path (loader.dll)\n      --payload <PAYLOAD>      The payload DLL path (payload.dll)\n      --function <FUNCTION>    The function to execute inside payload.dll (SayHello)\n      --parameter <PARAMETER>  The parameter to pass to the function inside payload.dll (https://localhost:1337/)\n      --output <OUTPUT>        The output file path (shellcode.bin)\n      --flags <FLAGS>          The 0x0 flag will execute DllMain and any other flag will execute the function inside payload.dll (SayHello) [default: 1]\n  -h, --help                   Print help\n  -V, --version                Print version\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs\\target\\release>\n```\n\n3). Bring your own injector (BYOI) and inject the position-independent code with your favourite injection and execution technique or use the one in the repository.\n\n```\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs\\target\\release> .\\inject.exe -h\nSimple Injector for PoC\n\nUsage: inject.exe --process <PROCESS> --file <FILE>\n\nOptions:\n      --process <PROCESS>  The target process name (notepad.exe)\n      --file <FILE>        The PIC file path (shellcode.bin)\n  -h, --help               Print help\n  -V, --version            Print version\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs\\target\\release>\n```\n\n## Example\n\n```\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs> cargo build --release\n    Finished release [optimized] target(s) in 0.04s\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs>\n```\n\n### DLLMain\n\n```\nPS C:\\Users\\memN0ps\\Documents\\GitHub\\srdi-rs\\target\\release> .\\generate_shellcode.exe --loader .\\reflective_loader.dll --payload .\\payload.dll\n... (truncated)"
    }
  }
]