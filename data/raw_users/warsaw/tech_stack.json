[
  {
    "name": "warsaw/dbus-python",
    "stars": 1,
    "description": "Mirror of upstream dbus-python repository with some musing and additions",
    "languages_breakdown": {
      "C": 413620,
      "Python": 305387,
      "Shell": 8934,
      "C++": 1948
    },
    "files": {}
  },
  {
    "name": "warsaw/importlib_resources",
    "stars": 1,
    "description": "Design and implementation for a planned importlib.resources",
    "languages_breakdown": {
      "Python": 13561
    },
    "files": {
      "README.rst": "``importlib.resources``\n=======================\nThis repository is to house the design and implementation of a planned\n``importlib.resources`` module for Python's stdlib -- aiming for\nPython 3.7 -- along with a backport to target Python 3.4 - 3.6.\n\nThe key goal of this module is to replace\n`pkg_resources <https://setuptools.readthedocs.io/en/latest/pkg_resources.html>`_\nwith a solution in Python's stdlib that relies on well-defined APIs.\nThis should not only make reading resources included in packages easier,\nbut have the semantics be stable and consistent.\n\nGoals\n-----\n\n- Provide a reasonable replacement for ``pkg_resources.resource_stream()``\n- Provide a reasonable replacement for ``pkg_resources.resource_string()``\n- Provide a reasonable replacement for ``pkg_resources.resource_filename()``\n- Define an ABC for loaders to implement for reading resources\n- Implement this in the stdlib for Python 3.7\n- Implement a package for PyPI which will work on Python >=3.4\n\nNon-goals\n---------\n- Replace all of ``pkg_resources``\n- For what is replaced in ``pkg_resources``, provide an **exact**\n  replacement\n\nDesign\n======\nLow-level\n---------\nFor `importlib.abc <https://docs.python.org/3/library/importlib.html#module-importlib.abc>`_::\n\n    import abc\n    from typing.io import BinaryIO\n\n\n    class ResourceReader(abc.ABC):\n\n        def open_resource(self, path: str) -> BinaryIO:\n            \"\"\"Return a file-like object opened for binary reading.\n\n            The 'path' argument is expected to represent only a file name.\n            If the resource cannot be found, FileNotFoundError is raised.\n            \"\"\"\n            raise FileNotFoundError\n\n        def resource_path(self, path: str) -> str:\n            \"\"\"Return the file system path to the specified resource.\n\n\n            The 'path' argument is expected to represent only a file name.\n            If the resource does not exist on the file system, raise\n            FileNotFoundError.\n            \"\"\"\n            raise FileNotFoundError\n\nHigh-level\n----------\nFor ``importlib.resources``::\n\n    import pathlib\n    import types\n    from typing import ContextManager, Union\n    from typing.io import BinaryIO\n\n\n    Package = Union[str, types.ModuleType]\n    FileName = Union[str, os.PathLike]\n\n\n    def open(package: Package, file_name: FileName) -> BinaryIO:\n        \"\"\"Return a file-like object opened for binary-reading of the resource.\"\"\"\n        ...\n\n\n    def read(package: Package, file_name: FileName, encoding: str = \"utf-8\",\n            errors: str = \"strict\") -> str:\n        \"\"\"Return the decoded string of the resource.\n\n        The decoding-related arguments have the same semantics as those of\n        bytes.decode().\n        \"\"\"\n        ...\n\n\n    @contextlib.contextmanager\n    def path(package: Package, file_name: FileName) -> ContextManager[pathlib.Path]:\n        \"\"\"A context manager providing a file path object to the resource.\n\n        If the resource does not already exist on its own on the file system,\n  \n... (truncated)"
    }
  },
  {
    "name": "warsaw/lazyimport",
    "stars": 1,
    "description": "Python lazy import crazy idea 2017 sprint prototype implementation tools stuff",
    "languages_breakdown": {
      "Python": 30021
    },
    "files": {
      "README.md": "# lazyimport\nPython lazy import crazy idea 2017 sprint prototype implementation tools stuff\n"
    }
  }
]