{
  "username": "abruzzi",
  "agent_b_context": "\n=== PR #42 in tfrce/thedaywefightback.js (Stars: 232) ===\n\n=== PR #487 in ZenUml/web-sequence (Stars: 145) ===\n\n=== PR #486 in ZenUml/web-sequence (Stars: 145) ===\n\n=== Fallback Source Audit: public/mockServiceWorker.js (Size: 8928 bytes) ===\n/* eslint-disable */\n/* tslint:disable */\n\n/**\n * Mock Service Worker.\n * @see https://github.com/mswjs/msw\n * - Please do NOT modify this file.\n */\n\nconst PACKAGE_VERSION = '2.10.5'\nconst INTEGRITY_CHECKSUM = 'f5825c521429caf22a4dd13b66e243af'\nconst IS_MOCKED_RESPONSE = Symbol('isMockedResponse')\nconst activeClientIds = new Set()\n\naddEventListener('install', function () {\n  self.skipWaiting()\n})\n\naddEventListener('activate', function (event) {\n  event.waitUntil(self.clients.claim())\n})\n\naddEventListener('message', async function (event) {\n  const clientId = Reflect.get(event.source || {}, 'id')\n\n  if (!clientId || !self.clients) {\n    return\n  }\n\n  const client = await self.clients.get(clientId)\n\n  if (!client) {\n    return\n  }\n\n  const allClients = await self.clients.matchAll({\n    type: 'window',\n  })\n\n  switch (event.data) {\n    case 'KEEPALIVE_REQUEST': {\n      sendToClient(client, {\n        type: 'KEEPALIVE_RESPONSE',\n      })\n      break\n    }\n\n    case 'INTEGRITY_CHECK_REQUEST': {\n      sendToClient(client, {\n        type: 'INTEGRITY_CHECK_RESPONSE',\n        payload: {\n          packageVersion: PACKAGE_VERSION,\n          checksum: INTEGRITY_CHECKSUM,\n        },\n      })\n      break\n    }\n\n    case 'MOCK_ACTIVATE': {\n      activeClientIds.add(clientId)\n\n      sendToClient(client, {\n        type: 'MOCKING_ENABLED',\n        payload: {\n          client: {\n            id: client.id,\n            frameType: client.frameType,\n          },\n        },\n      })\n      break\n    }\n\n    case 'MOCK_DEACTIVATE': {\n      activeClientIds.delete(clientId)\n      break\n    }\n\n    case 'CLIENT_CLOSED': {\n      activeClientIds.delete(clientId)\n\n      const remainingClients = allClients.filter((client) => {\n        return client.id !== clientId\n      })\n\n      // Unregister itself when there are no more clients\n      if (remainingClients.length === 0) {\n        self.registration.unregister()\n      }\n\n      break\n    }\n  }\n})\n\naddEventListener('fetch', function (event) {\n  // Bypass navigation requests.\n  if (event.request.mode === 'navigate') {\n    return\n  }\n\n  // Opening the DevTools triggers the \"only-if-cached\" request\n  // that cannot be handled by the worker. Bypass such requests.\n  if (\n    event.request.cache === 'only-if-cached' &&\n    event.request.mode !== 'same-origin'\n  ) {\n    return\n  }\n\n  // Bypass all requests when there are no active clients.\n  // Prevents the self-unregistered worked from handling requests\n  // after it's been deleted (still remains active until the next reload).\n  if (activeClientIds.size === 0) {\n    return\n  }\n\n  const requestId = crypto.randomUUID()\n  event.respondWith(handleRequest(event, requestId))\n})\n\n/**\n * @param {FetchEvent} event\n * @param {string} requestId\n */\nasync function handleRequest(event, requestId) {\n  const client = await resolveMainClient(event)\n  const requestCloneForEvents = event.request.clone()\n  const response = await getResponse(event, client, requestId)\n\n  // Send back the response clone for the \n... (file truncated)\n"
}