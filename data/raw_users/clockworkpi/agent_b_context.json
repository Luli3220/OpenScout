{
  "username": "clockworkpi",
  "agent_b_context": "\n=== PR #31 in clockworkpi/PicoCalc (Stars: 578) ===\nFile: Code/pico_multi_booter/sd_boot/main.c\nPatch:\n@@ -15,6 +15,8 @@\n #include <stdio.h>\n #include <string.h>\n #include \"pico/stdlib.h\"\n+#include \"pico/bootrom.h\"\n+#include \"pico/usb_reset_interface.h\"\n #include \"hardware/gpio.h\"\n #include \"hardware/clocks.h\"\n #include \"debug.h\"\n@@ -202,6 +204,35 @@ static bool is_valid_application(uint32_t *app_location)\n     return true;\n }\n \n+void boot_default()\n+{\n+    DEBUG_PRINT(\"entering boot_default\\n\");\n+    // Get the pointer to the application flash area\n+    uint32_t *app_location = (uint32_t *)(XIP_BASE + SD_BOOT_FLASH_OFFSET);\n+    launch_application_from(app_location);\n+    // We should never reach here\n+    while (1)\n+    {\n+        tight_loop_contents();\n+    }\n+}\n+\n+void boot_fwupdate()\n+{\n+    DEBUG_PRINT(\"entering boot_fwupdate\\n\");\n+    lcd_init();\n+    lcd_clear();\n+\n+    draw_rect_spi(20, 140, 300, 180, WHITE);\n+    lcd_set_cursor(30, 150);\n+    lcd_print_string_color((char *)\"FIRMWARE UPDATE\", BLACK, WHITE);\n+\n+    sleep_ms(2000);\n+\n+    uint gpio_mask = 0u;\n+    reset_usb_boot(\n... (truncated)\n\n\n=== PR #33 in clockworkpi/PicoCalc (Stars: 578) ===\nFile: Code/pico_multi_booter/picomite/Commands.c\nPatch:\n@@ -955,13 +955,13 @@ int printWrappedText(const char *text, int screenWidth, int listcnt, int all) {\n \r\n void cmd_help(void){\r\n \tgetargs(&cmdline,1,(unsigned char *)\",\");\r\n-\tif(!ExistsFile(\"A:/help.txt\"))error(\"A:/help.txt not found\");\r\n+\tif(!ExistsFile(\"B:/help.txt\"))error(\"B:/help.txt not found\");\r\n \tif(!argc){\r\n \t\tMMPrintString(\"Enter help and the name of the command or function\\r\\nUse * for multicharacter wildcard or ? for single character wildcard\\r\\n\");\r\n \t} else {\r\n \t\tint fnbr = FindFreeFileNbr();\r\n \t\tchar *buff=GetTempMemory(STRINGSIZE);\r\n-\t\tBasicFileOpen(\"A:/help.txt\",fnbr, FA_READ);\r\n+\t\tBasicFileOpen(\"B:/help.txt\",fnbr, FA_READ);\r\n \t\tint ListCnt = CurrentY/(FontTable[gui_font >> 4][1] * (gui_font & 0b1111)) + 2;\r\n \t\tchar *p=(char *)getCstring(argv[0]);\r\n \t\tbool end=false;\r\n@@ -1251,9 +1251,20 @@ void MIPS16 __not_in_flash_func(cmd_if)(void) {\n \t\t\t\t\t\t// and it is just a number, so get it and find the line\r\n \t\t\t\t\t\tnextstmt = findline(getinteger(argv[4]), true);\r\n \t\t\t\t\telse {\r\n\n... (truncated)\n\nFile: Code/pico_multi_booter/picomite/Draw.c\nPatch:\n@@ -46,7 +46,6 @@ extern mutex_t\tframeBufferMutex;\n #define LONG long\r\n #define max(x, y) (((x) > (y)) ? (x) : (y))\r\n #define min(x, y) (((x) < (y)) ? (x) : (y))\r\n-#define RoundUptoInt(a)     (((a) + (32 - 1)) & (~(32 - 1)))// round up to the nearest whole integer\r\n void DrawFilledCircle(int x, int y, int radius, int r, int fill, int ints_per_line, uint32_t *br, MMFLOAT aspect, MMFLOAT aspect2);\r\n void hline(int x0, int x1, int y, int f, int ints_per_line, uint32_t *br);\r\n void SaveTriangle(int bnbr, char *buff);\r\n@@ -118,7 +117,7 @@ typedef struct _BMPDECODER\n short gui_font;\r\n int gui_fcolour;\r\n int gui_bcolour;\r\n-short low_y=LCDMaxV, high_y=0, low_x=LCDMaxH, high_x=0;\r\n+short low_y=2000, high_y=-1, low_x=2000, high_x=-1;\r\n int PrintPixelMode=0;\r\n \r\n short CurrentX=0, CurrentY=0;                                             // the current default position for the next char to be written\r\n@@ -4982,7 +4981,7 @@ void restorepanel(void){\n             DrawPixel = DrawPixelNormal;\r\n        \n... (truncated)\n\nFile: Code/pico_multi_booter/picomite/Editor.c\nPatch:\n@@ -374,8 +374,8 @@ void edit(unsigned char *cmdline, bool cmdfile) {\n         gui_fcolour = WHITE;\r\n         gui_bcolour = BLACK;\r\n     }\r\n-    if(Option.DISPLAY_CONSOLE == true && gui_font_width > 16*HRes/640) error(\"Font is too large\");\r\n-    if(Option.DISPLAY_TYPE>=VIRTUAL && WriteBuf)FreeMemorySafe((void **)&WriteBuf);\r\n+    if(Option.DISPLAY_CONSOLE == true && HRes/gui_font_width <32) error(\"Font is too large\");\r\n+    if(Option.DISPLAY_TYPE>=VIRTUAL  && Option.DISPLAY_TYPE<NEXTGEN && WriteBuf)FreeMemorySafe((void **)&WriteBuf);\r\n     if(cmdfile){\r\n         ClearVars(0,true);\r\n         ClearRuntime(true);\r\n@@ -578,12 +578,9 @@ void FullScreenEditor(int xx, int yy, char *fname, int edit_buff_size, bool cmdf\n   int ytileheightsave;\r\n   ytileheightsave=ytileheight;\r\n   OptionY_TILESave=Y_TILE;\r\n-  if(!Option.ColourCode)ytileheight=16;\r\n-  else {\r\n-        ytileheight=gui_font_height;\r\n-        Y_TILE=VRes/ytileheight;\r\n-        if(VRes % ytileheight)Y_TILE++;\r\n-  }\r\n+  ytileheight=gu\n... (truncated)\n\nFile: Code/pico_multi_booter/picomite/External.c\nPatch:\n@@ -1581,31 +1581,16 @@ void cmd_port(void) {\n         \tif(!code)pin=codemap(pincode);\r\n         \telse pin=pincode;\r\n             if(IsInvalidPin(pin) || !(ExtCurrentConfig[pin] == EXT_DIG_OUT )) error(\"Invalid output pin\");\r\n-            gpio_set_input_enabled(PinDef[pin].GPno, true);\r\n             mask |=(1<<PinDef[pin].GPno);\r\n             if(value & 1)setmask |= (1<<PinDef[pin].GPno);\r\n             value >>= 1;\r\n             nbr--;\r\n             pincode++;\r\n         }\r\n     } \r\n-    readmask=gpio_get_all64();\r\n+    readmask=gpio_get_out_level_all64();\r\n     readmask &=mask;\r\n-    gpio_xor_mask64(setmask ^ readmask);\r\n-#ifdef rp2350\r\n-    #ifdef PICOMITEWEB\r\n-        int n=NBRPINS;\r\n-    #else\r\n-        int n=rp2350a ? 44: NBRPINS;\r\n-    #endif\r\n-#else\r\n-    int n=NBRPINS;\r\n-#endif\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(mask & 1)gpio_set_input_enabled(PinDef[i].GPno, false);\r\n-        mask>>=1;\r\n-    }\r\n+    gpio_xor_mask(setmask ^ readmask);\r\n }\r\n \r\n \r\n@@ -1660,6 +1645,7 @@ vo\n... (truncated)\n\n\n=== PR #30 in clockworkpi/PicoCalc (Stars: 578) ===\n"
}