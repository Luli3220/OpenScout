[
  {
    "name": "louthy/language-ext",
    "stars": 6989,
    "description": "C# pure functional programming framework - come and get declarative!",
    "languages_breakdown": {
      "C#": 7055058,
      "Shell": 3524,
      "Batchfile": 1703
    },
    "files": {
      "README.md": "![lang-ext](https://raw.githubusercontent.com/louthy/language-ext/main/Images/banner.png)\n\nC# Functional Programming Language Extensions\n=============================================\n\nThis library uses and abuses the features of C# to provide a pure functional-programming framework that, if you squint, can look like \nextensions to the language itself. The desire here is to make programming in C# much more robust by helping the engineer's inertia flow \nin the direction of declarative and pure functional code rather than imperative.  Using these techniques for large code-bases can bring \ntangible benefits to long-term maintenance by removing hidden complexity and by easing the engineer's and team's cognitive load.\n\n[![GitHub Discussions](https://raw.githubusercontent.com/louthy/language-ext/main/Images/discussions.svg)](https://github.com/louthy/language-ext/discussions)\n\n__Author on...__\n* __Blog__: [Notes from a Small Functional Island](https://paullouth.com/)\n* __Bluesky__: [@paullouth.bsky.social](https://bsky.app/profile/paullouth.bsky.social)\n* __Mastodon:__ [@louthy@4four.org](https://4four.org/@louthy)\n* __Github ReadME project__: ['Functional programming is finally going mainstream'](https://github.com/readme/featured/functional-programming)\n\n## Contents\n\n* [Reference](#reference)\n* [Nu-get package](#nu-get)\n* [Getting started](#getting-started)\n* [Prologue](#prologue)\n* [**Features**](#features)\n  * [Functional effects and IO](#functional-effects-and-io)\n  * [Atomic concurrency, shared state, and collections](#atomic-concurrency-and-collections)\n  * [Immutable collections](#immutable-collections)\n  * [Functional streams](#functional-streams)\n  * [Optional and Alternative value monads](#optional-and-alternative-value-monads)\n  * [State managing monads](#state-managing-monads)\n  * [Parser combinators](#parser-combinators)\n  * [Pretty: Produce nicely formatted text with smart layouts](#pretty)\n  * [Differencing](#differencing)\n  * [Traits](#traits)\n  * [Value traits](#value-traits)\n* [Contributing & Code of Conduct](#contributing--code-of-conduct)\n\n\n## Reference\n\n* [API Reference](https://louthy.github.io/language-ext/)\n* [Issues that contain documentation and examples](https://github.com/louthy/language-ext/issues?utf8=%E2%9C%93&q=is%3Aissue%20label%3A%22examples%20%2F%20documentation%22%20)\n\n## Nu-get\n\nNu-get package | Description\n---------------|-------------\n[LanguageExt.Parsec](https://www.nuget.org/packages/LanguageExt.Parsec) | Port of the [Haskell parsec library](https://hackage.haskell.org/package/parsec)\n[LanguageExt.Streaming](https://www.nuget.org/packages/LanguageExt.Streaming) | A set of compositional streaming types \n[LanguageExt.FSharp](https://www.nuget.org/packages/LanguageExt.FSharp) | F# to C# interop package. Provides interop between the LanguageExt.Core types (like `Option`, `List` and `Map`) to the F# equivalents, as well as interop between core BCL types and F#\n[LanguageExt.Parsec](https://www.nuget.org/packages/Langu\n... (truncated)"
    }
  },
  {
    "name": "louthy/csharp-monad",
    "stars": 474,
    "description": "Library of monads for C#",
    "languages_breakdown": {
      "C#": 408370
    },
    "files": {
      "README.md": "# Before going any further!!!\n\nFor a more complete (and active) functional framework including most of the monads listed above, please check my other project: [Language-Ext](https://github.com/louthy/language-ext)\n\n\ncsharp-monad\n============\n\nA C# library of monads and a full set of parser combinators based on the Haskell Parsec library.\n\n* `Either<L, R>`\n* `EitherStrict<L, R>`\n* `IO<T>`\n* `Option<T>`\n* `OptionStrict<T>`\n* `Parser<T>`\n* `Reader<E,T>`\n* `RWS<R,W,S,T>` - Combined Reader/Writer/State\n* `State<S,T>`\n* `Try<T>`\n* `Writer<W,T>`\n\nThe library is stable, functional and pretty well tested.\n\n__NuGet__ https://www.nuget.org/packages/csharp-monad/\n\n\n\n### A note about laziness\n\nAll of the C# monads in this library (except for those ending in `Strict`) are either delegates or they are wrappers for delegates (as in the case of the `Parser<T>`).  They all require invoking in one way or another to get to the underlying value.  This could cause performance problems if you're not careful.  For example, the `Option<T>` monad has `Value()` and `HasValue()` extension methods:\n\n```C#\n        Option<T> option = from x in DoSomething()\n                           from y in DoSomethingElse()\n                           select x + y;\n        \n        if( option.HasValue() )\n        {\n                return option.Value();\n        }\n```\n`HasValue()` and `Value()` will both cause the LINQ expression above to be invoked.  Therefore you end up doing the same computation twice.  You can mitigate this by invoking the result once:\n```C#\n        Option<T> option = from x in DoSomething()\n                           from y in DoSomethingElse()\n                           select x + y;\n                           \n        OptionResult<T> result = option();          // This invokes the bind function\n        \n        if( result.HasValue )\n        {\n            return result.Value;        \n        }\n```\nOr by using the `Memo()` memoization extension method available on all of the non-strict monad types:\n```C#\n        Func<OptionResult<T>> result = (from x in DoSomething()\n                                        from y in DoSomethingElse()\n                                        select x + y)\n                                       .Memo();\n        \n        if( result().HasValue )\n        {\n            return result().Value;        \n        }\n```\nOr by either using the `Match` methods on each monad (see the documentation after this section):\n```C#\n        Func<int> res = (from x in DoSomething()\n                         from y in DoSomethingElse()\n                         select x + y)\n                        .Match(\n                             Just: v => v * 10,\n                             Nothing: 0\n                        );\n```\nNote that even `Match` uses laziness, but the testing for valid values is now encapsulated into a single expression.  You would still need to be careful when using the result `res`. \n\nAll of these are valid methods, they're designed to fit the var\n... (truncated)"
    }
  },
  {
    "name": "louthy/echo-process",
    "stars": 122,
    "description": "Actor library for C# with additional modules that support persistence to Redis, as well as JS integration",
    "languages_breakdown": {
      "C#": 987768,
      "JavaScript": 35551,
      "Batchfile": 279
    },
    "files": {
      "README.md": "![banner](https://github.com/louthy/echo-process/raw/master/Images/echo%20banner.png)\n\n# echo\nActor system that works alongside the functional framework [Language-Ext](https://github.com/louthy/language-ext)\n\nAn issue with working with C# is that no matter how much of [Language-Ext functional framework](https://github.com/louthy/language-ext) you take on-board, you will always end up bumping into mutable state or side-effecting systems.  A way around that is to package up the side-effects into atoms of functional computation that are attached to the mutable state (in whatever form it may take).  The [Actor model](https://en.wikipedia.org/wiki/Actor_model) + functional message handling expressions are the perfect programming model for that.  \n\nConcurrent programming in C# isn't a huge amount of fun.  Yes the TPL gets you lots of stuff for free, but it doesn't magically protect you from race conditions or accessing shared state, and definitely doesn't help with accessing shared external state like a database.\n\n### Documentation\n\nDocumention | Description\n------------|------------\n[Overview](https://github.com/louthy/echo-process/wiki/Process-system) | A quick guide to the core features of the `Process` system\n[`tell`](https://github.com/louthy/echo-process/wiki/Tell) | Send a message to a `Process` - This should be your prefered mechanism for communicating with processes\n[`ask`](https://github.com/louthy/echo-process/wiki/Ask) | Request/response for processes - use this sparingly.\n[Publish / Subscribe](https://github.com/louthy/echo-process/wiki/Publish) | Mechanism for a Process to publish messages and state.  Other processes can subscribe through their inbox or external systems can subscribe through Reactive streams (Observables).\n[Message dispatch](https://github.com/louthy/echo-process/wiki/Process-system-message-dispatch) | The power of any actor system, especially when it comes to a changing network topology is in its message routing and dispatching\n[ProcessId](https://github.com/louthy/echo-process/wiki/ProcessId) |  `Process` address/location mechansim\n[Routers](https://github.com/louthy/echo-process/wiki/Routers) | A router is a `Process`  that manage sets of 'worker' processes by routing the received messages, following pre-defined behaviours, e.g. Round-robin, broadcast, etc.\n[Dispatchers](https://github.com/louthy/echo-process/wiki/Dispatchers) | Similar to routers but without the need for a router process, all routing is done by the sender\n[Registered processes](https://github.com/louthy/echo-process/wiki/Registered-processes) | A sort of DNS for Processes, can also register dispatchers\n[Roles](https://github.com/louthy/echo-process/wiki/Roles) | A special type of dispatcher that's aware of the aliveness of cluster nodes and what their roles are\n\n### Getting started\n\nMake sure you have the `Echo.Process` DLL included in your project.  If you're using F# then you will also need to include `Echo.Process.FSharp`.\n\nIn C# you should be `usi\n... (truncated)"
    }
  }
]